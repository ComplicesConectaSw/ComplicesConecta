<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#000000" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="ComplicesConecta" />
    <title>ComplicesConectaSW - Conecta Social Comunidad</title>
    <meta name="description" content="ComplicesConectaSW - Plataforma de conexi贸n social" />
    <meta name="author" content="ComplicesConectaSW" />

    <meta property="og:title" content="ComplicesConectaSW - Conecta Social Comunidad" />
    <meta property="og:description" content="ComplicesConectaSW - Plataforma de conexi贸n social" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/placeholder.svg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@ComplicesConectaSW" />
    <meta name="twitter:image" content="/placeholder.svg" />
    
    <!-- CRTICO: PROTECCIN DE WALLETS - DEBE EJECUTARSE PRIMERO ANTES DE CUALQUIER OTRO SCRIPT -->
    <!-- SOLUCIN ULTRA AGRESIVA: Interceptar Object.defineProperty ANTES de que las extensiones se carguen -->
    <!-- TCNICA: Hacer propiedades configurables PROACTIVAMENTE usando Object.defineProperty con configurable:true -->
    <script>
      // EJECUCIN INMEDIATA SIN IIFE - MXIMA PRIORIDAD
      // Esta t茅cnica intercepta Object.defineProperty ANTES de que las extensiones lo usen
      (function() {
        'use strict';
        
        // Guardar el Object.defineProperty ORIGINAL antes de que cualquier extensi贸n lo modifique
        var _originalDefineProperty = Object.defineProperty;
        var _originalGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        
        // Lista de propiedades de wallet que necesitamos proteger
        var _walletProps = ['ethereum', 'solana', 'tronWeb', 'tronweb', 'bybitWallet', 'bybit', 'chainId', 'chainid'];
        
        // TCNICA CRTICA: Hacer propiedades configurables ANTES de que las extensiones las definan
        // Esto se ejecuta INMEDIATAMENTE, antes de que cualquier extensi贸n se cargue
        _walletProps.forEach(function(prop) {
          try {
            var desc = _originalGetOwnPropertyDescriptor(window, prop);
            if (desc) {
              // Si la propiedad ya existe, intentar hacerla configurable
              if (!desc.configurable) {
                try {
                  // Intentar eliminar la propiedad primero (solo si es posible)
                  delete window[prop];
                } catch(e) {
                  // Si no se puede eliminar, intentar redefinirla como configurable
                  try {
                    _originalDefineProperty(window, prop, {
                      configurable: true,
                      writable: desc.writable !== false,
                      enumerable: desc.enumerable !== false,
                      value: desc.value,
                      get: desc.get,
                      set: desc.set
                    });
                  } catch(e2) {
                    // Si falla, continuar - la propiedad ya est谩 protegida por otra extensi贸n
                  }
                }
              }
            } else {
              // Si la propiedad no existe, crear un placeholder configurable
              try {
                _originalDefineProperty(window, prop, {
                  configurable: true,
                  writable: true,
                  enumerable: true,
                  value: undefined
                });
              } catch(e) {
                // Si falla, continuar
              }
            }
          } catch(e) {
            // Silenciar errores al configurar propiedades
          }
        });
        
        // Interceptar Object.defineProperty de forma ULTRA AGRESIVA
        // Esta funci贸n se ejecuta ANTES de que las extensiones intenten definir propiedades
        Object.defineProperty = function(obj, prop, descriptor) {
          var propLower = String(prop).toLowerCase();
          var isWalletProp = _walletProps.some(function(wp) { return propLower === wp.toLowerCase(); });
          
          // Si es una propiedad de wallet en window, manejar de forma especial
          if (obj === window && isWalletProp) {
            // CRTICO: Asegurar que el descriptor sea configurable
            if (descriptor && typeof descriptor === 'object') {
              descriptor.configurable = true;
              // Si no tiene writable, establecerlo como true por defecto
              if (descriptor.writable === undefined && !descriptor.get && !descriptor.set) {
                descriptor.writable = true;
              }
            }
            
            // Intentar definir normalmente con descriptor configurable
            try {
              return _originalDefineProperty.call(this, obj, prop, descriptor);
            } catch(e) {
              // Si falla, verificar si es porque ya existe y no es configurable
              try {
                var existingDesc = _originalGetOwnPropertyDescriptor(window, prop);
                if (existingDesc && !existingDesc.configurable) {
                  // Propiedad no configurable - intentar hacerla configurable primero
                  try {
                    // Intentar eliminar la propiedad
                    delete window[prop];
                    // Si se puede eliminar, definirla de nuevo como configurable
                    return _originalDefineProperty.call(this, obj, prop, descriptor);
                  } catch(e2) {
                    // Si no se puede eliminar ni redefinir, simplemente retornar sin error
                    return obj;
                  }
                }
                // Si es configurable, intentar de nuevo
                return _originalDefineProperty.call(this, obj, prop, descriptor);
              } catch(e2) {
                // Cualquier error, simplemente retornar sin error
                return obj;
              }
            }
          }
          
          // Para otras propiedades, intentar normalmente
          try {
            return _originalDefineProperty.call(this, obj, prop, descriptor);
          } catch(e) {
            // Si es error relacionado con wallet, silenciar
            var errMsg = String(e && e.message || '').toLowerCase();
            if ((isWalletProp && obj === window) || 
                (errMsg.indexOf('cannot redefine property') !== -1 && isWalletProp) ||
                (errMsg.indexOf('cannot assign to read only') !== -1 && isWalletProp) ||
                (errMsg.indexOf('read only property') !== -1 && isWalletProp)) {
              return obj;
            }
            throw e;
          }
        };
      })();
    </script>
    <script>
      // PROTECCIN ULTRA AGRESIVA DE WALLETS - SIN IIFE PARA EJECUCIN INMEDIATA
      // Basado en mejores pr谩cticas: interceptar Object.defineProperty antes de extensiones
      
      // Guardar m茅todos originales INMEDIATAMENTE
      var _originalDefineProperty = Object.defineProperty;
      var _originalConsoleError = console.error;
      var _originalConsoleWarn = console.warn;
      var _originalWindowError = window.onerror;
      
      // Hacer propiedades de wallet configurables ANTES de que las extensiones las toquen
      var _walletProps = ['ethereum', 'solana', 'tronWeb', 'tronweb', 'bybitWallet', 'bybit', 'chainId', 'chainid'];
      _walletProps.forEach(function(prop) {
        try {
          var desc = Object.getOwnPropertyDescriptor(window, prop);
          if (desc && !desc.configurable) {
            // Intentar hacer configurable usando el descriptor original
            try {
              _originalDefineProperty(window, prop, {
                configurable: true,
                writable: desc.writable !== false,
                enumerable: desc.enumerable !== false,
                value: desc.value,
                get: desc.get,
                set: desc.set
              });
            } catch(e) {
              // Si falla, intentar eliminar primero (solo si es posible)
              try {
                if (desc.configurable === false) {
                  // No podemos hacer nada si no es configurable, pero intentamos interceptar
                }
              } catch(e2) {}
            }
          } else if (!desc) {
            // Si no existe, crear placeholder configurable
            try {
              _originalDefineProperty(window, prop, {
                configurable: true,
                writable: true,
                enumerable: true,
                value: undefined
              });
            } catch(e) {}
          }
        } catch(e) {
          // Silenciar errores al configurar propiedades
        }
      });
      
      // Interceptar Object.defineProperty de forma ULTRA AGRESIVA - SIN TRY-CATCH INTERNO
      Object.defineProperty = function(obj, prop, descriptor) {
        var propLower = String(prop).toLowerCase();
        var isWalletProp = _walletProps.some(function(wp) { return propLower === wp.toLowerCase(); });
        
        // Si es una propiedad de wallet en window, manejar de forma especial
        if (obj === window && isWalletProp) {
          // Intentar definir normalmente primero
          try {
            return _originalDefineProperty.call(this, obj, prop, descriptor);
          } catch(e) {
            // Si falla, verificar si es porque no es configurable
            try {
              var existingDesc = Object.getOwnPropertyDescriptor(window, prop);
              if (existingDesc && !existingDesc.configurable) {
                // Propiedad no configurable - simplemente retornar sin error
                return obj;
              }
              // Intentar de nuevo
              return _originalDefineProperty.call(this, obj, prop, descriptor);
            } catch(e2) {
              // Cualquier error, simplemente retornar sin error
              return obj;
            }
          }
        }
        
        // Para otras propiedades, intentar normalmente
        try {
          return _originalDefineProperty.call(this, obj, prop, descriptor);
        } catch(e) {
          // Si es error relacionado con wallet, silenciar
          var errMsg = String(e && e.message || '').toLowerCase();
          if ((isWalletProp && obj === window) || 
              (errMsg.indexOf('cannot redefine property') !== -1 && isWalletProp) ||
              (errMsg.indexOf('cannot assign to read only') !== -1 && isWalletProp) ||
              (errMsg.indexOf('read only property') !== -1 && isWalletProp)) {
            return obj;
          }
          throw e;
        }
      };
      
      // Interceptar console.error ULTRA AGRESIVO - MEJORADO
      console.error = function() {
        var args = Array.prototype.slice.call(arguments);
        var msg = args.join(' ').toLowerCase();
        var stack = '';
        
        // Buscar stack trace en los argumentos
        for (var i = 0; i < args.length; i++) {
          if (typeof args[i] === 'string' && args[i].indexOf('at ') !== -1) {
            stack = args[i].toLowerCase();
            break;
          }
          if (args[i] && typeof args[i] === 'object' && args[i].stack) {
            stack = String(args[i].stack).toLowerCase();
            break;
          }
        }
        
        var _walletPatterns = [
          'wallet', 'ethereum', 'solana', 'metamask', 'tronweb', 'tronlink', 'bybit', 'evmask',
          'cannot redefine property', 'cannot assign to read only', 'read only property',
          'which has only a getter', 'inpage.js', 'evmask.js', 'evmask.js:5', 'evmAsk.js',
          'evmAsk.js:5', 'solana.js', 'solana.js:3', 'solana.js:', 'dist.94abdbf1.js', 'dist.',
          'data-layer', 'inpage.js:154', 'inpage.js:168', 'inpage.js:1', 'inpage.js:',
          'chainid', 'chain id', 'tronweb is already initiated', 'tronlink will overwrite',
          'bybit:page provider', 'metamask encountered an error', 'metamask encountered',
          'wallet must has at least one account', 'wallet must have', 'wallet must',
          'code 4001', '4001', 'typeerror', 'cannot set property'
        ];
        
        // Verificar si es error de wallet por mensaje o stack
        var isWalletError = _walletPatterns.some(function(pattern) {
          return msg.indexOf(pattern) !== -1 || stack.indexOf(pattern) !== -1;
        });
        
        if (!isWalletError) {
          _originalConsoleError.apply(console, args);
        }
      };
      
      // Interceptar console.warn ULTRA AGRESIVO - MEJORADO
      console.warn = function() {
        var args = Array.prototype.slice.call(arguments);
        var msg = args.join(' ').toLowerCase();
        
        var _walletPatterns = [
          'wallet', 'ethereum', 'solana', 'metamask', 'tronweb', 'tronlink', 'bybit', 'evmask',
          'tronweb is already initiated', 'tronlink will overwrite', 'bybit:page provider inject code',
          'bybit:page provider', 'download the react devtools', 'inpage.js', 'evmask.js', 'evmAsk.js',
          'solana.js', 'dist.94abdbf1.js', 'data-layer', 'inpage.js:', 'evmAsk.js:', 'solana.js:'
        ];
        
        var isWalletWarning = _walletPatterns.some(function(pattern) {
          return msg.indexOf(pattern) !== -1;
        });
        
        if (!isWalletWarning) {
          _originalConsoleWarn.apply(console, args);
        }
      };
      
      // Interceptar window.onerror DIRECTAMENTE (m谩s temprano que addEventListener)
      window.onerror = function(msg, url, line, col, error) {
        var msgLower = String(msg || '').toLowerCase();
        var urlLower = String(url || '').toLowerCase();
        var stackLower = String(error && error.stack || '').toLowerCase();
        
        var _walletPatterns = [
          'cannot redefine property', 'cannot assign to read only', 'read only property',
          'which has only a getter', 'wallet', 'ethereum', 'solana', 'metamask',
          'tronweb', 'tronlink', 'bybit', 'evmask', 'chainid', 'chain id',
          'wallet must has at least one account', 'wallet must have', 'wallet must',
          'metamask encountered an error', 'metamask encountered',
          'tronweb is already initiated', 'tronlink will overwrite',
          'bybit:page provider', 'code 4001', '4001', 'typeerror'
        ];
        
        var _walletFiles = [
          'solana.js', 'solana.js:3', 'solana.js:', 'inpage.js', 'inpage.js:154',
          'inpage.js:168', 'inpage.js:1', 'inpage.js:', 'evmask.js', 'evmAsk.js',
          'evmAsk.js:5', 'evmAsk.js:', 'dist.94abdbf1.js', 'dist.', 'data-layer',
          'chunk', 'wallet'
        ];
        
        var isWalletError = _walletPatterns.some(function(pattern) {
          return msgLower.indexOf(pattern) !== -1 || stackLower.indexOf(pattern) !== -1;
        }) || _walletFiles.some(function(file) {
          return urlLower.indexOf(file) !== -1 || stackLower.indexOf(file) !== -1;
        });
        
        if (isWalletError) {
          return true; // Prevenir propagaci贸n del error
        }
        
        // Si hay un handler original, llamarlo
        if (_originalWindowError) {
          return _originalWindowError.call(this, msg, url, line, col, error);
        }
        return false;
      };
      
      // Interceptar errores globales ULTRA AGRESIVO - CAPTURA EN FASE DE CAPTURA
      window.addEventListener('error', function(e) {
        var msg = String(e.message || '').toLowerCase();
        var filename = String(e.filename || '').toLowerCase();
        var stack = String(e.error && e.error.stack || '').toLowerCase();
        
        var _walletPatterns = [
          'cannot redefine property', 'cannot assign to read only', 'read only property',
          'which has only a getter', 'wallet', 'ethereum', 'solana', 'metamask',
          'tronweb', 'tronlink', 'bybit', 'evmask', 'chainid', 'chain id',
          'wallet must has at least one account', 'wallet must have', 'wallet must',
          'metamask encountered an error', 'metamask encountered',
          'tronweb is already initiated', 'tronlink will overwrite',
          'bybit:page provider', 'code 4001', '4001', 'typeerror'
        ];
        
        var _walletFiles = [
          'solana.js', 'solana.js:3', 'solana.js:', 'inpage.js', 'inpage.js:154',
          'inpage.js:168', 'inpage.js:1', 'inpage.js:', 'evmask.js', 'evmAsk.js',
          'evmAsk.js:5', 'evmAsk.js:', 'dist.94abdbf1.js', 'dist.', 'data-layer',
          'chunk', 'wallet'
        ];
        
        var isWalletError = _walletPatterns.some(function(pattern) {
          return msg.indexOf(pattern) !== -1 || stack.indexOf(pattern) !== -1;
        }) || _walletFiles.some(function(file) {
          return filename.indexOf(file) !== -1 || stack.indexOf(file) !== -1;
        });
        
        if (isWalletError) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return false;
        }
      }, true); // CAPTURA EN FASE DE CAPTURA (antes de otros handlers)
      
      // Interceptar promise rejections ULTRA AGRESIVO
      window.addEventListener('unhandledrejection', function(e) {
        var reason = e.reason;
        var msg = String(reason && (reason.message || reason.toString()) || '').toLowerCase();
        var stack = String(reason && reason.stack || '').toLowerCase();
        var code = String(reason && reason.code || '').toLowerCase();
        
        var _walletPatterns = [
          'cannot redefine property', 'cannot assign to read only', 'read only property',
          'wallet must has at least one account', 'wallet must have', 'wallet must',
          'metamask encountered an error', 'metamask encountered', 'metamask',
          'tronweb is already initiated', 'tronweb', 'tronlink will overwrite', 'tronlink',
          'bybit:page provider', 'bybit', 'solana', 'ethereum', 'chainid', 'chain id',
          'wallet', 'evmask', 'code 4001', '4001'
        ];
        
        var _walletFiles = [
          'solana.js', 'solana.js:3', 'solana.js:', 'inpage.js', 'inpage.js:154',
          'inpage.js:168', 'inpage.js:1', 'inpage.js:', 'evmask.js', 'evmAsk.js',
          'evmAsk.js:5', 'evmAsk.js:', 'dist.94abdbf1.js', 'dist.', 'data-layer',
          'chunk', 'wallet'
        ];
        
        var isWalletError = _walletPatterns.some(function(pattern) {
          return msg.indexOf(pattern) !== -1 || stack.indexOf(pattern) !== -1 || code.indexOf(pattern) !== -1;
        }) || _walletFiles.some(function(file) {
          return stack.indexOf(file) !== -1;
        }) || code === '4001' || (reason && typeof reason === 'object' && 'code' in reason && reason.code === 4001);
        
        if (isWalletError) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return false;
        }
      }, true); // CAPTURA EN FASE DE CAPTURA
    </script>
    
    <!-- CRTICO: Asegurar React disponible globalmente ANTES de chunks -->
    <script>
      // CRTICO: Establecer stub de React INMEDIATAMENTE - ANTES de logging
      // Esto debe ejecutarse ANTES de cualquier otro c贸digo
      // SOLUCIN DIRECTA: Interceptar TODOS los accesos posibles a React
      (function() {
        // Stub completo de React con TODOS los hooks necesarios
        var reactStub = {
          createContext: function(defaultValue) {
            return {
              Provider: function(props) { return props && props.children || null; },
              Consumer: function(props) { return props && props.children ? props.children(defaultValue) : null; },
              displayName: 'Context',
              _currentValue: defaultValue,
              $$typeof: Symbol.for('react.context')
            };
          },
          createElement: function() { return null; },
          Fragment: function(props) { return props ? props.children : null; },
          useState: function(initial) { return [initial, function() {}]; },
          useEffect: function() { return function() {}; },
          // CRTICO: useLayoutEffect debe estar disponible SIEMPRE
          useLayoutEffect: function(callback, deps) {
            if (typeof callback === 'function') {
              try {
                var result = callback();
                return typeof result === 'function' ? result : function() {};
              } catch(e) {
                return function() {};
              }
            }
            return function() {};
          },
          useMemo: function(fn) { return fn(); },
          useCallback: function(fn) { return fn; },
          useContext: function(context) { return context ? context._currentValue : null; },
          StrictMode: function(props) { return props ? props.children : null; },
          // Asegurar que todos los otros hooks tambi茅n est茅n disponibles
          useRef: function(initial) { return { current: initial }; },
          useReducer: function() { return [null, function() {}]; },
          useImperativeHandle: function() {},
          useDebugValue: function() {},
          version: '18.3.1'
        };
        
        // CRTICO: Interceptar acceso a propiedades usando Proxy ANTES de definir window.React
        // Esto captura accesos como: React.useLayoutEffect donde React es undefined
        var reactProxy = null;
        if (typeof Proxy !== 'undefined') {
          try {
            reactProxy = new Proxy(reactStub, {
              get: function(target, prop) {
                // Si el prop es useLayoutEffect y no existe, retornar funci贸n stub
                if (prop === 'useLayoutEffect') {
                  return target.useLayoutEffect || function() { return function() {}; };
                }
                // Para cualquier otro prop, retornar del target o undefined
                return target[prop] !== undefined ? target[prop] : (function() {
                  // Si es un hook que no existe, retornar funci贸n stub
                  if (prop.toString().startsWith('use')) {
                    return function() { return undefined; };
                  }
                  return undefined;
                })();
              },
              has: function(target, prop) {
                // Siempre decir que useLayoutEffect existe
                if (prop === 'useLayoutEffect') return true;
                return prop in target;
              }
            });
          } catch(e) {
            // Si Proxy falla, usar el stub directamente
            reactProxy = reactStub;
          }
        } else {
          reactProxy = reactStub;
        }
        
        // CRTICO: Establecer window.React usando defineProperty con getter/setter
        // Esto asegura que incluso si se accede antes de que est茅 definido, retorne el stub
        try {
          Object.defineProperty(window, 'React', {
            get: function() {
              // Si ya existe el React real, usarlo; si no, usar el stub
              return window.__REACT_REAL__ || reactProxy || reactStub;
            },
            set: function(value) {
              // Guardar el React real cuando se asigne
              window.__REACT_REAL__ = value;
              // Asegurar que useLayoutEffect est茅 disponible
              if (value && !value.useLayoutEffect) {
                value.useLayoutEffect = reactStub.useLayoutEffect;
              }
            },
            configurable: true,
            enumerable: true
          });
        } catch(e) {
          // Si defineProperty falla, asignar directamente
          window.React = reactProxy || reactStub;
        }
        
        // Tambi茅n establecer directamente por si acaso
        window.React = window.React || reactProxy || reactStub;
        window.__REACT_STUB__ = reactStub;
        window.__REACT_REAL__ = null;
        
        // CRTICO: Interceptar accesos a propiedades de undefined usando Object.prototype
        // ELIMINADO: Este interceptor causaba recursi贸n infinita
        // var originalPropertyAccess = Object.prototype.valueOf;
        // Object.prototype.valueOf = function() {
        //   // Si alguien intenta acceder a useLayoutEffect en un objeto que podr铆a ser React
        //   if (this === window || this === globalThis) {
        //     // Asegurar que React est茅 disponible
        //     if (!window.React) {
        //       window.React = reactProxy || reactStub;
        //     }
        //   }
        //   return originalPropertyAccess.call(this);
        // };
      })();
      
      // LOGGING: Inicializar sistema de logging para diagn贸stico
      window.__LOADING_DEBUG__ = {
        timestamps: [],
        events: [],
        log: function(event, data) {
          var timestamp = performance.now();
          this.timestamps.push(timestamp);
          this.events.push({ event: event, timestamp: timestamp, data: data || {} });
          if (window.location.hostname === 'localhost' || window.location.hostname.includes('dev')) {
            console.log('[LOADING]', event, data || '');
          }
        },
        getReport: function() {
          return {
            events: this.events,
            duration: this.timestamps.length > 0 ? this.timestamps[this.timestamps.length - 1] - this.timestamps[0] : 0,
            reactAvailable: typeof window !== 'undefined' && !!window.React,
            reactContextAvailable: typeof window !== 'undefined' && !!window.React && !!window.React.createContext
          };
        }
      };
      
      // POLYFILL REACT: Asegurar que React.createContext est茅 disponible globalmente
      // Esto debe ejecutarse ANTES de que cualquier chunk se cargue
      window.__LOADING_DEBUG__.log('POLYFILL_INIT', { timestamp: Date.now() });
      
      // POLYFILL ELIMINADO: No es necesario y puede causar problemas
      // React se carga antes de que se use createContext gracias al orden de carga
      window.__LOADING_DEBUG__.log('POLYFILL_SKIPPED', { hasReact: !!window.React });
    </script>
    
    <!-- CRTICO: Inyectar React INMEDIATAMENTE en <head> ANTES de que Vite agregue modulepreload -->
    <script>
      // PROTECCIN CRTICA: Mejorar stub de React y asegurar que est茅 disponible
      // El stub ya est谩 establecido arriba, aqu铆 solo mejoramos la protecci贸n
      (function() {
        // Obtener stub existente o crear uno nuevo
        var reactStub = window.__REACT_STUB__ || window.React || {
          createContext: function(defaultValue) {
            // Stub de createContext que funciona y ser谩 reemplazado cuando React real se cargue
            var context = {
              Provider: function(props) { 
                if (props && props.children) return props.children; 
                return null; 
              },
              Consumer: function(props) { 
                if (props && props.children) return props.children(defaultValue); 
                return null; 
              },
              displayName: 'Context',
              _currentValue: defaultValue,
              $$typeof: Symbol.for('react.context')
            };
            return context;
          },
          createElement: function() { return null; },
          Fragment: function(props) { return props ? props.children : null; },
          useState: function(initial) { return [initial, function() {}]; },
          useEffect: function() { return function() {}; },
          useLayoutEffect: function(callback, deps) { 
            // CRTICO: useLayoutEffect debe estar disponible en el stub
            // Si hay callback, ejecutarlo inmediatamente (sincr贸nicamente)
            if (typeof callback === 'function') {
              try {
                return callback();
              } catch(e) {
                return function() {};
              }
            }
            return function() {};
          },
          useMemo: function(fn) { return fn(); },
          useCallback: function(fn) { return fn; },
          useContext: function(context) { return context ? context._currentValue : null; },
          StrictMode: function(props) { return props ? props.children : null; }
        };
        
        // Guardar stub en m煤ltiples lugares para m谩xima compatibilidad
        window.__REACT_STUB__ = reactStub;
        window.__REACT_REAL__ = null;
        
        // Interceptar Object.defineProperty ANTES de que cualquier chunk se cargue
        var originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          // Si se intenta definir window.React, interceptarlo
          if (obj === window && (prop === 'React' || prop === 'react')) {
            // Guardar React real cuando se defina
            var reactValue = descriptor.value || (descriptor.get && descriptor.get());
            if (reactValue) {
              window.__REACT_REAL__ = reactValue;
              // Asegurar que createContext est茅 disponible
              if (!reactValue.createContext) {
                reactValue.createContext = reactStub.createContext;
              }
            }
            // Llamar original pero asegurar que el stub est茅 disponible
            try {
              return originalDefineProperty.call(this, obj, prop, descriptor);
            } catch(e) {
              // Si falla, usar el stub
              return originalDefineProperty.call(this, obj, prop, {
                get: function() { return window.__REACT_REAL__ || reactStub; },
                configurable: true,
                enumerable: true
              });
            }
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };
        
        // PROTECCIN FINAL: Proxy simplificado para evitar recursi贸n infinita
        var reactProxy;
        var reactGetterCalled = false; // Flag para evitar recursi贸n
        try {
          reactProxy = new Proxy(reactStub, {
            get: function(target, prop) {
              // Evitar recursi贸n: si ya estamos accediendo, usar stub directamente
              if (reactGetterCalled) {
                return target[prop] || function() { return function() {}; };
              }
              
              reactGetterCalled = true;
              try {
                // Si se accede a useLayoutEffect, asegurar que est茅 disponible
                if (prop === 'useLayoutEffect') {
                  var realReact = window.__REACT_REAL__;
                  if (realReact && realReact.useLayoutEffect) {
                    reactGetterCalled = false;
                    return realReact.useLayoutEffect;
                  }
                  reactGetterCalled = false;
                  return target.useLayoutEffect || function(callback, deps) {
                    if (typeof callback === 'function') {
                      try {
                        return callback();
                      } catch(e) {
                        return function() {};
                      }
                    }
                    return function() {};
                  };
                }
                // Si React real est谩 disponible, usarlo; sino, usar stub
                var realReact = window.__REACT_REAL__;
                if (realReact && realReact[prop]) {
                  reactGetterCalled = false;
                  return realReact[prop];
                }
                reactGetterCalled = false;
                return target[prop] || function() { return function() {}; };
              } catch(e) {
                reactGetterCalled = false;
                return target[prop] || function() { return function() {}; };
              }
            }
          });
          
          // Reemplazar el stub con el proxy
          reactStub = reactProxy;
          window.__REACT_STUB__ = reactProxy;
        } catch(e) {
          // Si Proxy no est谩 disponible, usar el stub directamente
          reactProxy = reactStub;
        }
        
        // Hacer que window.React apunte al stub INMEDIATAMENTE usando defineProperty
        // SIMPLIFICADO: Evitar recursi贸n infinita en el getter
        try {
          var windowReactGetterCalled = false; // Flag para evitar recursi贸n
          Object.defineProperty(window, 'React', {
            get: function() {
              // Evitar recursi贸n infinita
              if (windowReactGetterCalled) {
                return reactStub;
              }
              windowReactGetterCalled = true;
              try {
                // Si React real ya est谩 disponible, usarlo; sino, usar stub (proxy)
                var realReact = window.__REACT_REAL__;
                if (realReact) {
                  // Asegurar que useLayoutEffect est茅 disponible en React real
                  if (!realReact.useLayoutEffect) {
                    realReact.useLayoutEffect = reactStub.useLayoutEffect;
                  }
                  windowReactGetterCalled = false;
                  return realReact;
                }
                windowReactGetterCalled = false;
                return reactProxy || reactStub;
              } catch(e) {
                windowReactGetterCalled = false;
                return reactStub;
              }
            },
            set: function(value) {
              // Guardar React real cuando se defina
              window.__REACT_REAL__ = value;
              // Asegurar que createContext y useLayoutEffect est茅n disponibles
              if (value) {
                if (!value.createContext) {
                  value.createContext = reactStub.createContext;
                }
                if (!value.useLayoutEffect) {
                  value.useLayoutEffect = reactStub.useLayoutEffect;
                }
              }
            },
            configurable: true,
            enumerable: true
          });
        } catch(e) {
          // Si falla, usar asignaci贸n directa
          window.React = reactProxy || reactStub;
        }
        
        // PROTECCIN EXTRA: Interceptar accesos a React.createContext directamente
        // ELIMINADO: Este interceptor causaba recursi贸n infinita
        // var originalGetPropertyDescriptor = Object.getOwnPropertyDescriptor;
        // Object.getOwnPropertyDescriptor = function(obj, prop) {
        //   if (obj === window && (prop === 'React' || prop === 'react')) {
        //     var desc = originalGetPropertyDescriptor.call(this, obj, prop);
        //     if (!desc) {
        //       return {
        //         get: function() { return window.__REACT_REAL__ || reactProxy || reactStub; },
        //         configurable: true,
        //         enumerable: true
        //       };
        //     }
        //   }
        //   return originalGetPropertyDescriptor.call(this, obj, prop);
        // };
        
        // Log para debugging
        if (window.__LOADING_DEBUG__) {
          window.__LOADING_DEBUG__.log('REACT_STUB_CREATED_HEAD', { 
            timestamp: Date.now(),
            hasStub: !!window.__REACT_STUB__,
            hasReact: !!window.React
          });
        }
      })();
    </script>
    
    <!-- SOLUCIN ALTERNATIVA: Hacer propiedades de wallet configurables ANTES de que las extensiones las toquen -->
    <script>
      // EJECUCIN INMEDIATA SIN IIFE - MXIMA PRIORIDAD
      var walletProtection = {
        originalDefineProperty: Object.defineProperty,
        originalConsoleError: console.error,
        originalConsoleWarn: console.warn
      };
      
      // Hacer propiedades configurables ANTES de que se definan
      var walletProps = ['ethereum', 'solana', 'tronWeb', 'tronweb', 'bybitWallet', 'bybit', 'chainId', 'chainid'];
      walletProps.forEach(function(prop) {
        try {
          var desc = Object.getOwnPropertyDescriptor(window, prop);
          if (desc && !desc.configurable) {
            try {
              Object.defineProperty(window, prop, {
                configurable: true,
                writable: desc.writable !== false,
                enumerable: desc.enumerable !== false,
                value: desc.value,
                get: desc.get,
                set: desc.set
              });
            } catch(e) {}
          }
        } catch(e) {}
      });
      
      // Interceptar Object.defineProperty
      Object.defineProperty = function(obj, prop, descriptor) {
        var propLower = String(prop).toLowerCase();
        if (obj === window && walletProps.some(function(wp) { return propLower === wp.toLowerCase(); })) {
          try {
            return walletProtection.originalDefineProperty.call(this, obj, prop, descriptor);
          } catch(e) {
            return obj;
          }
        }
        try {
          return walletProtection.originalDefineProperty.call(this, obj, prop, descriptor);
        } catch(e) {
          var errMsg = String(e && e.message || '').toLowerCase();
          if (walletProps.some(function(wp) { return propLower === wp.toLowerCase(); }) && obj === window) {
            return obj;
          }
          throw e;
        }
      };
      
      // Silenciar console
      console.error = function() {
        var msg = Array.prototype.join.call(arguments, ' ').toLowerCase();
        if (msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 ||
            msg.indexOf('metamask') !== -1 || msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 ||
            msg.indexOf('bybit') !== -1 || msg.indexOf('evmask') !== -1 || msg.indexOf('cannot redefine') !== -1 ||
            msg.indexOf('cannot assign to read only') !== -1 || msg.indexOf('read only property') !== -1 ||
            msg.indexOf('which has only a getter') !== -1 || msg.indexOf('inpage.js') !== -1 ||
            msg.indexOf('evmask.js') !== -1 || msg.indexOf('evmAsk.js') !== -1 || msg.indexOf('data-layer') !== -1 || 
            msg.indexOf('solana.js') !== -1 || msg.indexOf('dist.94abdbf1.js') !== -1 || msg.indexOf('chainid') !== -1 ||
            msg.indexOf('solana.js:3') !== -1 || msg.indexOf('evmAsk.js:5') !== -1 || msg.indexOf('inpage.js:154') !== -1 ||
            msg.indexOf('inpage.js:168') !== -1 || msg.indexOf('inpage.js:1') !== -1) {
          return;
        }
        walletProtection.originalConsoleError.apply(console, arguments);
      };
      
      console.warn = function() {
        var msg = Array.prototype.join.call(arguments, ' ').toLowerCase();
        if (msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 ||
            msg.indexOf('metamask') !== -1 || msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 ||
            msg.indexOf('bybit') !== -1 || msg.indexOf('evmask') !== -1 || msg.indexOf('overwrite') !== -1) {
          return;
        }
        walletProtection.originalConsoleWarn.apply(console, arguments);
      };
      
      // Interceptar errores
      window.addEventListener('error', function(e) {
        var msg = String(e.message || '').toLowerCase();
        var filename = String(e.filename || '').toLowerCase();
        var stack = String(e.error && e.error.stack || '').toLowerCase();
        if (msg.indexOf('cannot redefine property') !== -1 || msg.indexOf('cannot assign to read only') !== -1 ||
            msg.indexOf('read only property') !== -1 || msg.indexOf('which has only a getter') !== -1 ||
            msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 ||
            msg.indexOf('metamask') !== -1 || msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 ||
            msg.indexOf('bybit') !== -1 || msg.indexOf('evmask') !== -1 ||
            filename.indexOf('inpage.js') !== -1 || filename.indexOf('evmask.js') !== -1 ||
            filename.indexOf('evmAsk.js') !== -1 || filename.indexOf('solana.js') !== -1 || 
            filename.indexOf('data-layer') !== -1 || filename.indexOf('dist.94abdbf1.js') !== -1 ||
            stack.indexOf('inpage.js') !== -1 || stack.indexOf('evmask.js') !== -1 ||
            stack.indexOf('evmAsk.js') !== -1 || stack.indexOf('solana.js') !== -1 || 
            stack.indexOf('data-layer') !== -1 || stack.indexOf('dist.94abdbf1.js') !== -1 ||
            stack.indexOf('solana.js:3') !== -1 || stack.indexOf('evmAsk.js:5') !== -1 ||
            stack.indexOf('inpage.js:154') !== -1 || stack.indexOf('inpage.js:168') !== -1 ||
            stack.indexOf('inpage.js:1') !== -1) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return false;
        }
      }, true);
      
      // Interceptar promise rejections
      window.addEventListener('unhandledrejection', function(e) {
        var reason = e.reason;
        var msg = String(reason && (reason.message || reason.toString()) || '').toLowerCase();
        var stack = String(reason && reason.stack || '').toLowerCase();
        var code = String(reason && reason.code || '').toLowerCase();
        if (msg.indexOf('cannot redefine property') !== -1 || msg.indexOf('cannot assign to read only') !== -1 ||
            msg.indexOf('read only property') !== -1 || msg.indexOf('which has only a getter') !== -1 ||
            msg.indexOf('wallet must') !== -1 || msg.indexOf('wallet') !== -1 ||
            msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 || msg.indexOf('metamask') !== -1 ||
            msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 || msg.indexOf('bybit') !== -1 ||
            msg.indexOf('evmask') !== -1 || msg.indexOf('chainid') !== -1 ||
            msg.indexOf('inpage.js') !== -1 || msg.indexOf('evmask.js') !== -1 || 
            msg.indexOf('evmAsk.js') !== -1 || msg.indexOf('data-layer') !== -1 ||
            msg.indexOf('solana.js') !== -1 || msg.indexOf('dist.94abdbf1.js') !== -1 ||
            stack.indexOf('inpage.js') !== -1 || stack.indexOf('evmask.js') !== -1 ||
            stack.indexOf('evmAsk.js') !== -1 || stack.indexOf('data-layer') !== -1 || 
            stack.indexOf('solana.js') !== -1 || stack.indexOf('dist.94abdbf1.js') !== -1 ||
            stack.indexOf('solana.js:3') !== -1 || stack.indexOf('evmAsk.js:5') !== -1 ||
            stack.indexOf('inpage.js:154') !== -1 || stack.indexOf('inpage.js:168') !== -1 ||
            stack.indexOf('inpage.js:1') !== -1 ||
            code === '4001' || (reason && typeof reason === 'object' && 'code' in reason && reason.code === 4001)) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return false;
        }
      }, true);
    </script>
  </head>

  <body>
    <div id="root">
      <!-- Loading fallback - se reemplaza cuando React carga -->
      <div style="min-height: 100vh; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #6b21a8 0%, #3b82f6 100%);">
        <div style="color: white; text-align: center;">
          <div style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
          <p>Cargando...</p>
        </div>
      </div>
    </div>
    <!-- Script duplicado eliminado - ya est谩 en <head> y se ejecuta primero -->
    
    <!-- CRTICO: Error handler global TEMPRANO para capturar errores antes de que React se monte -->
    <script>
      // Error handler global - captura errores ANTES de que React se monte
      window.addEventListener('error', function(e) {
        // Solo capturar errores que NO sean de wallet (ya est谩n silenciados)
        var msg = String(e.message || '').toLowerCase();
        var filename = String(e.filename || '').toLowerCase();
        var stack = String(e.error && e.error.stack || '').toLowerCase();
        
        // IGNORAR errores con message undefined que vienen de archivos de wallet
        var hasUndefinedMessage = !e.message || e.message === 'undefined' || e.message === '';
        var isWalletFile = filename.indexOf('inpage.js') !== -1 || filename.indexOf('evmask.js') !== -1 ||
                          filename.indexOf('evmAsk.js') !== -1 || filename.indexOf('solana.js') !== -1 ||
                          filename.indexOf('wallet') !== -1 || filename.indexOf('dist.') !== -1 ||
                          filename.indexOf('chunk') !== -1 || filename.indexOf('data-layer') !== -1;
        
        var isWalletError = msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || 
                           msg.indexOf('solana') !== -1 || msg.indexOf('metamask') !== -1 ||
                           filename.indexOf('inpage.js') !== -1 || filename.indexOf('evmask.js') !== -1 ||
                           filename.indexOf('evmAsk.js') !== -1 || filename.indexOf('solana.js') !== -1 || 
                           stack.indexOf('inpage.js') !== -1 || stack.indexOf('evmask.js') !== -1 ||
                           stack.indexOf('evmAsk.js') !== -1 || stack.indexOf('solana.js') !== -1 ||
                           stack.indexOf('solana.js:3') !== -1 || stack.indexOf('evmAsk.js:5') !== -1 ||
                           stack.indexOf('inpage.js:154') !== -1 || stack.indexOf('inpage.js:168') !== -1 ||
                           stack.indexOf('inpage.js:1') !== -1 || msg.indexOf('cannot redefine') !== -1 ||
                           msg.indexOf('cannot assign to read only') !== -1 ||
                           (hasUndefinedMessage && isWalletFile); // IGNORAR errores undefined de wallet
        
        if (!isWalletError) {
          // Loggear error real para diagn贸stico
          console.error(' Error global capturado:', {
            message: e.message,
            filename: e.filename,
            line: e.lineno,
            column: e.colno,
            error: e.error
          });
          
          // Loggear al sistema de debugging si est谩 disponible
          if (window.__LOADING_DEBUG__) {
            window.__LOADING_DEBUG__.log('GLOBAL_ERROR', {
              message: e.message,
              filename: e.filename,
              line: e.lineno,
              column: e.colno
            });
          }
        }
      }, true);
      
      // Promise rejection handler global
      window.addEventListener('unhandledrejection', function(e) {
        var reason = e.reason;
        var msg = String(reason && (reason.message || reason.toString()) || '').toLowerCase();
        var stack = String(reason && reason.stack || '').toLowerCase();
        
        var isWalletError = msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || 
                           msg.indexOf('solana') !== -1 || msg.indexOf('metamask') !== -1 ||
                           stack.indexOf('inpage.js') !== -1 || stack.indexOf('evmask.js') !== -1;
        
        if (!isWalletError) {
          // Loggear error real para diagn贸stico
          console.error(' Promise rejection global capturada:', {
            reason: reason,
            message: reason?.message,
            stack: reason?.stack
          });
          
          // Loggear al sistema de debugging si est谩 disponible
          if (window.__LOADING_DEBUG__) {
            window.__LOADING_DEBUG__.log('GLOBAL_PROMISE_REJECTION', {
              reason: reason?.message || String(reason),
              stack: reason?.stack
            });
          }
        }
      }, true);
    </script>
    
    <!-- CRTICO: Interceptar TODOS los accesos a React ANTES de que cualquier chunk se cargue -->
    <script>
      // PROTECCIN ULTRA CRTICA: Interceptar accesos a propiedades de objetos que podr铆an ser React
      // Esto se ejecuta ANTES de que cualquier m贸dulo ES6 se importe
      (function() {
        // Interceptar Object.defineProperty para React
        var originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          if (obj === window && (prop === 'React' || prop === 'react')) {
            var reactValue = descriptor.value || (descriptor.get && descriptor.get());
            if (reactValue) {
              window.__REACT_REAL__ = reactValue;
              // Asegurar useLayoutEffect
              if (!reactValue.useLayoutEffect) {
                reactValue.useLayoutEffect = window.__REACT_STUB__?.useLayoutEffect || function() { return function() {}; };
              }
            }
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };
        
        // PROTECCIN CRTICA: Interceptar accesos a propiedades de objetos undefined
        // ELIMINADO: Este interceptor causaba recursi贸n infinita - simplificado
        // var originalGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        // Object.getOwnPropertyDescriptor = function(obj, prop) {
        //   if (obj === window && (prop === 'React' || prop === 'react')) {
        //     var desc = originalGetOwnPropertyDescriptor.call(this, obj, prop);
        //     if (!desc) {
        //       // Si no hay descriptor, crear uno con el stub
        //       return {
        //         get: function() {
        //           return window.__REACT_REAL__ || window.__REACT_STUB__ || window.React || {
        //             useLayoutEffect: function() { return function() {}; },
        //             useEffect: function() { return function() {}; },
        //             useState: function() { return [null, function() {}]; },
        //             createContext: function() { return { Provider: function() {}, Consumer: function() {} }; }
        //           };
        //         },
        //         configurable: true,
        //         enumerable: true
        //       };
        //     }
        //     if (desc && desc.get) {
        //       // Interceptar el getter
        //       var originalGetter = desc.get;
        //       desc.get = function() {
        //         var react = originalGetter.call(this);
        //         // Asegurar useLayoutEffect SIEMPRE
        //         if (!react || !react.useLayoutEffect) {
        //           var stub = window.__REACT_STUB__ || window.__REACT_REAL__;
        //           if (stub && stub.useLayoutEffect) {
        //             if (react) {
        //               react.useLayoutEffect = stub.useLayoutEffect;
        //             } else {
        //               react = stub;
        //             }
        //           } else {
        //             react = react || {
        //               useLayoutEffect: function() { return function() {}; },
        //               useEffect: function() { return function() {}; },
        //               useState: function() { return [null, function() {}]; },
        //               createContext: function() { return { Provider: function() {}, Consumer: function() {} }; }
        //             };
        //           }
        //         }
        //         return react;
        //       };
        //     }
        //     return desc;
        //   }
        //   return originalGetOwnPropertyDescriptor.call(this, obj, prop);
        // };
        
        // PROTECCIN EXTRA: Interceptar Proxy.constructor para m贸dulos ES6
        // ELIMINADO: Este interceptor causaba recursi贸n infinita
        // if (typeof Proxy !== 'undefined') {
        //   var OriginalProxy = Proxy;
        //   try {
        //     Proxy = function(target, handler) {
        //       // Si el target es React o tiene useLayoutEffect, interceptarlo
        //       if (target && (target.useLayoutEffect || target === window.React || target === window.__REACT_STUB__)) {
        //         var originalGet = handler.get;
        //         handler.get = function(target, prop, receiver) {
        //           if (prop === 'useLayoutEffect') {
        //             var result = originalGet ? originalGet.call(this, target, prop, receiver) : target[prop];
        //             if (!result) {
        //               return function() { return function() {}; };
        //             }
        //             return result;
        //           }
        //           return originalGet ? originalGet.call(this, target, prop, receiver) : target[prop];
        //         };
        //       }
        //       return new OriginalProxy(target, handler);
        //     };
        //   } catch(e) {
        //     // Si falla, no hacer nada
        //   }
        // }
        
        // PROTECCIN FINAL: Interceptar accesos a propiedades de objetos undefined
        // ELIMINADO: Estos interceptores causaban recursi贸n infinita
        // var originalHasOwnProperty = Object.prototype.hasOwnProperty;
        // Object.prototype.hasOwnProperty = function(prop) {
        //   // Si alguien pregunta por useLayoutEffect en cualquier objeto, asegurar que est茅 disponible
        //   if (prop === 'useLayoutEffect' && this === window.React) {
        //     return true; // Siempre decir que existe
        //   }
        //   return originalHasOwnProperty.call(this, prop);
        // };
        
        // PROTECCIN EXTRA: Interceptar accesos a propiedades usando bracket notation
        // ELIMINADO: Este interceptor causaba recursi贸n infinita
        // var originalValueOf = Object.prototype.valueOf;
        // Object.prototype.valueOf = function() {
        //   // Si este objeto es React y no tiene useLayoutEffect, agregarlo
        //   if (this === window.React || this === window.__REACT_STUB__ || this === window.__REACT_REAL__) {
        //     if (!this.useLayoutEffect) {
        //       this.useLayoutEffect = window.__REACT_STUB__?.useLayoutEffect || function() { return function() {}; };
        //     }
        //   }
        //   return originalValueOf.call(this);
        // };
      })();
    </script>
    
    <!-- CRTICO: Pre-cargar vendor-react ANTES de main.tsx para asegurar que React est茅 disponible -->
    <script type="module">
      // CRTICO: Asegurar que React est茅 disponible ANTES de que cualquier m贸dulo se ejecute
      // Esto se ejecuta ANTES de que Vite cargue los chunks
      (function() {
        // Verificar que React est茅 disponible
        if (!window.React) {
          console.error(' React no est谩 disponible antes de cargar m贸dulos');
          // Forzar uso del stub si est谩 disponible
          if (window.__REACT_STUB__) {
            window.React = window.__REACT_STUB__;
          } else {
            // Si no hay stub, crear uno m铆nimo
            window.React = {
              useLayoutEffect: function() { return function() {}; },
              useEffect: function() { return function() {}; },
              useState: function() { return [null, function() {}]; },
              createContext: function() { return { Provider: function() {}, Consumer: function() {} }; },
              createElement: function() { return null; }
            };
          }
        }
        
        // CRTICO: Interceptar accesos a propiedades de undefined usando Proxy
        // Esto captura accesos como: React.useLayoutEffect donde React podr铆a ser undefined temporalmente
        if (typeof Proxy !== 'undefined' && !window.__REACT_PROXY_INSTALLED__) {
          try {
            var originalReact = window.React;
            var reactProxy = new Proxy(originalReact || {}, {
              get: function(target, prop) {
                // Si el target es undefined o null, usar el stub
                if (!target || target === window || target === globalThis) {
                  var stub = window.__REACT_STUB__ || window.React;
                  if (stub && stub[prop]) {
                    return stub[prop];
                  }
                  // Si es useLayoutEffect, SIEMPRE retornar funci贸n
                  if (prop === 'useLayoutEffect') {
                    return function() { return function() {}; };
                  }
                  // Si es otro hook, retornar funci贸n stub
                  if (prop.toString().startsWith('use')) {
                    return function() { return undefined; };
                  }
                  return undefined;
                }
                // Si el target tiene la propiedad, retornarla
                if (prop in target) {
                  return target[prop];
                }
                // Si no existe pero es useLayoutEffect, retornar funci贸n stub
                if (prop === 'useLayoutEffect') {
                  return function() { return function() {}; };
                }
                return undefined;
              }
            });
            window.React = reactProxy;
            window.__REACT_PROXY_INSTALLED__ = true;
          } catch(e) {
            // Si falla, asegurar que React est茅 disponible directamente
            window.React = window.React || window.__REACT_STUB__ || {
              useLayoutEffect: function() { return function() {}; }
            };
          }
        }
        
        // Validaci贸n final: asegurar que useLayoutEffect est茅 disponible
        if (!window.React || !window.React.useLayoutEffect) {
          if (!window.React) window.React = {};
          window.React.useLayoutEffect = function() { return function() {}; };
        }
      })();
    </script>
    <script type="module" src="/src/main.tsx"></script>
    <style>
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
  </body>
</html>
