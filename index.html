<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#000000" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="ComplicesConecta" />
    <title>ComplicesConectaSW - Conecta Social Comunidad</title>
    <meta name="description" content="ComplicesConectaSW - Plataforma de conexi√≥n social" />
    <meta name="author" content="ComplicesConectaSW" />

    <meta property="og:title" content="ComplicesConectaSW - Conecta Social Comunidad" />
    <meta property="og:description" content="ComplicesConectaSW - Plataforma de conexi√≥n social" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/placeholder.svg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@ComplicesConectaSW" />
    <meta name="twitter:image" content="/placeholder.svg" />
    <!-- CR√çTICO: Asegurar React disponible globalmente ANTES de chunks -->
    <script>
      // CR√çTICO: Establecer stub de React INMEDIATAMENTE - ANTES de logging
      // Esto debe ejecutarse ANTES de cualquier otro c√≥digo
      (function() {
        var reactStub = {
          createContext: function(defaultValue) {
            return {
              Provider: function(props) { return props && props.children || null; },
              Consumer: function(props) { return props && props.children ? props.children(defaultValue) : null; },
              displayName: 'Context',
              _currentValue: defaultValue,
              $$typeof: Symbol.for('react.context')
            };
          },
          createElement: function() { return null; },
          Fragment: function(props) { return props ? props.children : null; },
          useState: function(initial) { return [initial, function() {}]; },
          useEffect: function() { return function() {}; },
          useLayoutEffect: function(callback, deps) {
            if (typeof callback === 'function') {
              try {
                return callback();
              } catch(e) {
                return function() {};
              }
            }
            return function() {};
          },
          useMemo: function(fn) { return fn(); },
          useCallback: function(fn) { return fn; },
          useContext: function(context) { return context ? context._currentValue : null; },
          StrictMode: function(props) { return props ? props.children : null; }
        };
        
        // CR√çTICO: Establecer window.React INMEDIATAMENTE - antes de cualquier import
        try {
          Object.defineProperty(window, 'React', {
            value: reactStub,
            writable: true,
            configurable: true,
            enumerable: true
          });
        } catch(e) {
          window.React = reactStub;
        }
        
        window.__REACT_STUB__ = reactStub;
        window.__REACT_REAL__ = null;
      })();
      
      // LOGGING: Inicializar sistema de logging para diagn√≥stico
      window.__LOADING_DEBUG__ = {
        timestamps: [],
        events: [],
        log: function(event, data) {
          var timestamp = performance.now();
          this.timestamps.push(timestamp);
          this.events.push({ event: event, timestamp: timestamp, data: data || {} });
          if (window.location.hostname === 'localhost' || window.location.hostname.includes('dev')) {
            console.log('[LOADING]', event, data || '');
          }
        },
        getReport: function() {
          return {
            events: this.events,
            duration: this.timestamps.length > 0 ? this.timestamps[this.timestamps.length - 1] - this.timestamps[0] : 0,
            reactAvailable: typeof window !== 'undefined' && !!window.React,
            reactContextAvailable: typeof window !== 'undefined' && !!window.React && !!window.React.createContext
          };
        }
      };
      
      // POLYFILL REACT: Asegurar que React.createContext est√© disponible globalmente
      // Esto debe ejecutarse ANTES de que cualquier chunk se cargue
      window.__LOADING_DEBUG__.log('POLYFILL_INIT', { timestamp: Date.now() });
      
      // POLYFILL ELIMINADO: No es necesario y puede causar problemas
      // React se carga antes de que se use createContext gracias al orden de carga
      window.__LOADING_DEBUG__.log('POLYFILL_SKIPPED', { hasReact: !!window.React });
    </script>
    
    <!-- CR√çTICO: Inyectar React INMEDIATAMENTE en <head> ANTES de que Vite agregue modulepreload -->
    <script>
      // PROTECCI√ìN CR√çTICA: Mejorar stub de React y asegurar que est√© disponible
      // El stub ya est√° establecido arriba, aqu√≠ solo mejoramos la protecci√≥n
      (function() {
        // Obtener stub existente o crear uno nuevo
        var reactStub = window.__REACT_STUB__ || window.React || {
          createContext: function(defaultValue) {
            // Stub de createContext que funciona y ser√° reemplazado cuando React real se cargue
            var context = {
              Provider: function(props) { 
                if (props && props.children) return props.children; 
                return null; 
              },
              Consumer: function(props) { 
                if (props && props.children) return props.children(defaultValue); 
                return null; 
              },
              displayName: 'Context',
              _currentValue: defaultValue,
              $$typeof: Symbol.for('react.context')
            };
            return context;
          },
          createElement: function() { return null; },
          Fragment: function(props) { return props ? props.children : null; },
          useState: function(initial) { return [initial, function() {}]; },
          useEffect: function() { return function() {}; },
          useLayoutEffect: function(callback, deps) { 
            // CR√çTICO: useLayoutEffect debe estar disponible en el stub
            // Si hay callback, ejecutarlo inmediatamente (sincr√≥nicamente)
            if (typeof callback === 'function') {
              try {
                return callback();
              } catch(e) {
                return function() {};
              }
            }
            return function() {};
          },
          useMemo: function(fn) { return fn(); },
          useCallback: function(fn) { return fn; },
          useContext: function(context) { return context ? context._currentValue : null; },
          StrictMode: function(props) { return props ? props.children : null; }
        };
        
        // Guardar stub en m√∫ltiples lugares para m√°xima compatibilidad
        window.__REACT_STUB__ = reactStub;
        window.__REACT_REAL__ = null;
        
        // Interceptar Object.defineProperty ANTES de que cualquier chunk se cargue
        var originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          // Si se intenta definir window.React, interceptarlo
          if (obj === window && (prop === 'React' || prop === 'react')) {
            // Guardar React real cuando se defina
            var reactValue = descriptor.value || (descriptor.get && descriptor.get());
            if (reactValue) {
              window.__REACT_REAL__ = reactValue;
              // Asegurar que createContext est√© disponible
              if (!reactValue.createContext) {
                reactValue.createContext = reactStub.createContext;
              }
            }
            // Llamar original pero asegurar que el stub est√© disponible
            try {
              return originalDefineProperty.call(this, obj, prop, descriptor);
            } catch(e) {
              // Si falla, usar el stub
              return originalDefineProperty.call(this, obj, prop, {
                get: function() { return window.__REACT_REAL__ || reactStub; },
                configurable: true,
                enumerable: true
              });
            }
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };
        
        // PROTECCI√ìN FINAL: Proxy para interceptar TODOS los accesos a React.useLayoutEffect
        var reactProxy;
        try {
          reactProxy = new Proxy(reactStub, {
            get: function(target, prop) {
              // Si se accede a useLayoutEffect, asegurar que est√© disponible
              if (prop === 'useLayoutEffect') {
                var realReact = window.__REACT_REAL__;
                if (realReact && realReact.useLayoutEffect) {
                  return realReact.useLayoutEffect;
                }
                return target.useLayoutEffect || function(callback, deps) {
                  if (typeof callback === 'function') {
                    try {
                      return callback();
                    } catch(e) {
                      return function() {};
                    }
                  }
                  return function() {};
                };
              }
              // Si React real est√° disponible, usarlo; sino, usar stub
              var realReact = window.__REACT_REAL__;
              if (realReact && realReact[prop]) {
                return realReact[prop];
              }
              return target[prop] || function() { return function() {}; };
            }
          });
          
          // Reemplazar el stub con el proxy
          reactStub = reactProxy;
          window.__REACT_STUB__ = reactProxy;
        } catch(e) {
          // Si Proxy no est√° disponible, usar el stub directamente
          reactProxy = reactStub;
        }
        
        // Hacer que window.React apunte al stub INMEDIATAMENTE usando defineProperty
        try {
          Object.defineProperty(window, 'React', {
            get: function() {
              // Si React real ya est√° disponible, usarlo; sino, usar stub (proxy)
              var realReact = window.__REACT_REAL__;
              if (realReact) {
                // Asegurar que useLayoutEffect est√© disponible en React real
                if (!realReact.useLayoutEffect) {
                  realReact.useLayoutEffect = reactStub.useLayoutEffect;
                }
                return realReact;
              }
              return reactProxy || reactStub;
            },
            set: function(value) {
              // Guardar React real cuando se defina
              window.__REACT_REAL__ = value;
              // Asegurar que createContext y useLayoutEffect est√©n disponibles
              if (value) {
                if (!value.createContext) {
                  value.createContext = reactStub.createContext;
                }
                if (!value.useLayoutEffect) {
                  value.useLayoutEffect = reactStub.useLayoutEffect;
                }
              }
            },
            configurable: true,
            enumerable: true
          });
        } catch(e) {
          // Si falla, usar asignaci√≥n directa
          window.React = reactProxy || reactStub;
        }
        
        // PROTECCI√ìN EXTRA: Interceptar accesos a React.createContext directamente
        var originalGetPropertyDescriptor = Object.getOwnPropertyDescriptor;
        Object.getOwnPropertyDescriptor = function(obj, prop) {
          if (obj === window && (prop === 'React' || prop === 'react')) {
            var desc = originalGetPropertyDescriptor.call(this, obj, prop);
            if (!desc) {
              return {
                get: function() { return window.__REACT_REAL__ || reactProxy || reactStub; },
                configurable: true,
                enumerable: true
              };
            }
          }
          return originalGetPropertyDescriptor.call(this, obj, prop);
        };
        
        // Log para debugging
        if (window.__LOADING_DEBUG__) {
          window.__LOADING_DEBUG__.log('REACT_STUB_CREATED_HEAD', { 
            timestamp: Date.now(),
            hasStub: !!window.__REACT_STUB__,
            hasReact: !!window.React
          });
        }
      })();
    </script>
    
    <!-- SOLUCI√ìN ALTERNATIVA: Hacer propiedades de wallet configurables ANTES de que las extensiones las toquen -->
    <script>
      // EJECUCI√ìN INMEDIATA SIN IIFE - M√ÅXIMA PRIORIDAD
      var walletProtection = {
        originalDefineProperty: Object.defineProperty,
        originalConsoleError: console.error,
        originalConsoleWarn: console.warn
      };
      
      // Hacer propiedades configurables ANTES de que se definan
      var walletProps = ['ethereum', 'solana', 'tronWeb', 'tronweb', 'bybitWallet', 'bybit', 'chainId', 'chainid'];
      walletProps.forEach(function(prop) {
        try {
          var desc = Object.getOwnPropertyDescriptor(window, prop);
          if (desc && !desc.configurable) {
            try {
              Object.defineProperty(window, prop, {
                configurable: true,
                writable: desc.writable !== false,
                enumerable: desc.enumerable !== false,
                value: desc.value,
                get: desc.get,
                set: desc.set
              });
            } catch(e) {}
          }
        } catch(e) {}
      });
      
      // Interceptar Object.defineProperty
      Object.defineProperty = function(obj, prop, descriptor) {
        var propLower = String(prop).toLowerCase();
        if (obj === window && walletProps.some(function(wp) { return propLower === wp.toLowerCase(); })) {
          try {
            return walletProtection.originalDefineProperty.call(this, obj, prop, descriptor);
          } catch(e) {
            return obj;
          }
        }
        try {
          return walletProtection.originalDefineProperty.call(this, obj, prop, descriptor);
        } catch(e) {
          var errMsg = String(e && e.message || '').toLowerCase();
          if (walletProps.some(function(wp) { return propLower === wp.toLowerCase(); }) && obj === window) {
            return obj;
          }
          throw e;
        }
      };
      
      // Silenciar console
      console.error = function() {
        var msg = Array.prototype.join.call(arguments, ' ').toLowerCase();
        if (msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 ||
            msg.indexOf('metamask') !== -1 || msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 ||
            msg.indexOf('bybit') !== -1 || msg.indexOf('evmask') !== -1 || msg.indexOf('cannot redefine') !== -1 ||
            msg.indexOf('cannot assign to read only') !== -1 || msg.indexOf('read only property') !== -1 ||
            msg.indexOf('which has only a getter') !== -1 || msg.indexOf('inpage.js') !== -1 ||
            msg.indexOf('evmask.js') !== -1 || msg.indexOf('data-layer') !== -1 || msg.indexOf('solana.js') !== -1 ||
            msg.indexOf('dist.94abdbf1.js') !== -1 || msg.indexOf('chainid') !== -1) {
          return;
        }
        walletProtection.originalConsoleError.apply(console, arguments);
      };
      
      console.warn = function() {
        var msg = Array.prototype.join.call(arguments, ' ').toLowerCase();
        if (msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 ||
            msg.indexOf('metamask') !== -1 || msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 ||
            msg.indexOf('bybit') !== -1 || msg.indexOf('evmask') !== -1 || msg.indexOf('overwrite') !== -1) {
          return;
        }
        walletProtection.originalConsoleWarn.apply(console, arguments);
      };
      
      // Interceptar errores
      window.addEventListener('error', function(e) {
        var msg = String(e.message || '').toLowerCase();
        var filename = String(e.filename || '').toLowerCase();
        var stack = String(e.error && e.error.stack || '').toLowerCase();
        if (msg.indexOf('cannot redefine property') !== -1 || msg.indexOf('cannot assign to read only') !== -1 ||
            msg.indexOf('read only property') !== -1 || msg.indexOf('which has only a getter') !== -1 ||
            msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 ||
            msg.indexOf('metamask') !== -1 || msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 ||
            msg.indexOf('bybit') !== -1 || msg.indexOf('evmask') !== -1 ||
            filename.indexOf('inpage.js') !== -1 || filename.indexOf('evmask.js') !== -1 ||
            filename.indexOf('solana.js') !== -1 || filename.indexOf('data-layer') !== -1 ||
            filename.indexOf('dist.94abdbf1.js') !== -1 ||
            stack.indexOf('inpage.js') !== -1 || stack.indexOf('evmask.js') !== -1 ||
            stack.indexOf('solana.js') !== -1 || stack.indexOf('data-layer') !== -1) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return false;
        }
      }, true);
      
      // Interceptar promise rejections
      window.addEventListener('unhandledrejection', function(e) {
        var reason = e.reason;
        var msg = String(reason && (reason.message || reason.toString()) || '').toLowerCase();
        var stack = String(reason && reason.stack || '').toLowerCase();
        var code = String(reason && reason.code || '').toLowerCase();
        if (msg.indexOf('cannot redefine property') !== -1 || msg.indexOf('cannot assign to read only') !== -1 ||
            msg.indexOf('read only property') !== -1 || msg.indexOf('which has only a getter') !== -1 ||
            msg.indexOf('wallet must') !== -1 || msg.indexOf('wallet') !== -1 ||
            msg.indexOf('ethereum') !== -1 || msg.indexOf('solana') !== -1 || msg.indexOf('metamask') !== -1 ||
            msg.indexOf('tronweb') !== -1 || msg.indexOf('tronlink') !== -1 || msg.indexOf('bybit') !== -1 ||
            msg.indexOf('evmask') !== -1 || msg.indexOf('chainid') !== -1 ||
            msg.indexOf('inpage.js') !== -1 || msg.indexOf('evmask.js') !== -1 || msg.indexOf('data-layer') !== -1 ||
            msg.indexOf('solana.js') !== -1 || msg.indexOf('dist.94abdbf1.js') !== -1 ||
            stack.indexOf('inpage.js') !== -1 || stack.indexOf('evmask.js') !== -1 ||
            stack.indexOf('data-layer') !== -1 || stack.indexOf('solana.js') !== -1 ||
            code === '4001' || (reason && typeof reason === 'object' && 'code' in reason && reason.code === 4001)) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return false;
        }
      }, true);
    </script>
  </head>

  <body>
    <div id="root">
      <!-- Loading fallback - se reemplaza cuando React carga -->
      <div style="min-height: 100vh; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #6b21a8 0%, #3b82f6 100%);">
        <div style="color: white; text-align: center;">
          <div style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
          <p>Cargando...</p>
        </div>
      </div>
    </div>
    <!-- Script duplicado eliminado - ya est√° en <head> y se ejecuta primero -->
    
    <!-- CR√çTICO: Error handler global TEMPRANO para capturar errores antes de que React se monte -->
    <script>
      // Error handler global - captura errores ANTES de que React se monte
      window.addEventListener('error', function(e) {
        // Solo capturar errores que NO sean de wallet (ya est√°n silenciados)
        var msg = String(e.message || '').toLowerCase();
        var filename = String(e.filename || '').toLowerCase();
        var stack = String(e.error && e.error.stack || '').toLowerCase();
        
        var isWalletError = msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || 
                           msg.indexOf('solana') !== -1 || msg.indexOf('metamask') !== -1 ||
                           filename.indexOf('inpage.js') !== -1 || filename.indexOf('evmask.js') !== -1 ||
                           filename.indexOf('solana.js') !== -1 || stack.indexOf('inpage.js') !== -1;
        
        if (!isWalletError) {
          // Loggear error real para diagn√≥stico
          console.error('üö® Error global capturado:', {
            message: e.message,
            filename: e.filename,
            line: e.lineno,
            column: e.colno,
            error: e.error
          });
          
          // Loggear al sistema de debugging si est√° disponible
          if (window.__LOADING_DEBUG__) {
            window.__LOADING_DEBUG__.log('GLOBAL_ERROR', {
              message: e.message,
              filename: e.filename,
              line: e.lineno,
              column: e.colno
            });
          }
        }
      }, true);
      
      // Promise rejection handler global
      window.addEventListener('unhandledrejection', function(e) {
        var reason = e.reason;
        var msg = String(reason && (reason.message || reason.toString()) || '').toLowerCase();
        var stack = String(reason && reason.stack || '').toLowerCase();
        
        var isWalletError = msg.indexOf('wallet') !== -1 || msg.indexOf('ethereum') !== -1 || 
                           msg.indexOf('solana') !== -1 || msg.indexOf('metamask') !== -1 ||
                           stack.indexOf('inpage.js') !== -1 || stack.indexOf('evmask.js') !== -1;
        
        if (!isWalletError) {
          // Loggear error real para diagn√≥stico
          console.error('üö® Promise rejection global capturada:', {
            reason: reason,
            message: reason?.message,
            stack: reason?.stack
          });
          
          // Loggear al sistema de debugging si est√° disponible
          if (window.__LOADING_DEBUG__) {
            window.__LOADING_DEBUG__.log('GLOBAL_PROMISE_REJECTION', {
              reason: reason?.message || String(reason),
              stack: reason?.stack
            });
          }
        }
      }, true);
    </script>
    
    <script type="module" src="/src/main.tsx"></script>
    <style>
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
  </body>
</html>
