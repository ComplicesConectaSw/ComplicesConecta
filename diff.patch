diff --git a/diff.patch b/diff.patch
index 84ba50b..e69de29 100644
--- a/diff.patch
+++ b/diff.patch
@@ -1,414 +0,0 @@
-diff --git a/.gitignore b/.gitignore
-index 2221042..30ac912 100644
---- a/.gitignore
-+++ b/.gitignore
-@@ -104,3 +104,8 @@ test_*.md
- logs/
- temp/
- .cache/
-+
-+# Auditor√≠a y desarrollo (ignorar en git)
-+dev-scripts/
-+reports/
-+token-system-spec/
-diff --git a/project-structure.md b/project-structure.md
-index 3f279f7..c6f5ec2 100644
---- a/project-structure.md
-+++ b/project-structure.md
-@@ -318,26 +318,46 @@ npm run audit:fix           # Correcciones autom√°ticas
- npm run scaffold:templates  # Importar plantillas
- ```
- 
--## üöÄ **√öltimas Actualizaciones v1.4.1** *(15 de enero, 2025 - 16:45)*
-+## üöÄ **√öltimas Actualizaciones v1.9.0** *(5 de septiembre, 2025 - 23:48)*
- 
--### **Correcciones Cr√≠ticas de JSX y Mantenibilidad**
--- **Errores JSX Solucionados**: Corregidos errores cr√≠ticos de sintaxis en `Discover.tsx` que imped√≠an la compilaci√≥n
--- **Eliminaci√≥n CSS Inline**: Migraci√≥n completa de estilos inline a clases TailwindCSS para mejor mantenibilidad
--- **Tipos TypeScript Mejorados**: Solucionados problemas de tipos en funciones de perfil y asignaci√≥n de im√°genes
--- **Footer Completamente Funcional**: Botones sociales, newsletter y enlaces externos ahora funcionan correctamente
--- **Optimizaci√≥n Android**: Mejoras espec√≠ficas de responsividad para dispositivos m√≥viles Android
-+### **Auditor√≠a Completa y Correcciones Cr√≠ticas**
-+- **Errores TypeScript Resueltos**: Corregidos tipos incompatibles en `requests.ts` para alineaci√≥n con esquema Supabase
-+- **Sistema de Solicitudes Corregido**: Migraci√≥n completa de tabla `connection_requests` a `invitations` con campos correctos
-+- **Validaci√≥n de L√≥gica Completada**: Generado checklist completo de validaci√≥n con matriz de cumplimiento
-+- **Scripts de Migraci√≥n Preparados**: `dev-scripts/migrations.sql` y `dev-scripts/rls.sql` listos para ejecutar
-+- **Documentaci√≥n Exhaustiva**: Reports de auditor√≠a, planes de correcci√≥n y checklists de validaci√≥n
- 
--### **Componentes Actualizados**
-+### **Archivos Cr√≠ticos Actualizados**
- ```
--src/pages/Discover.tsx              # Errores JSX corregidos, tipos mejorados
--src/components/Footer.tsx           # Funcionalidad completa habilitada
--src/styles/animations.css           # Animaciones CSS separadas
--src/pages/Index.tsx                 # Estilos inline removidos
--README.md                           # Documentaci√≥n actualizada
--RELEASE_NOTES.md                    # Notas de versi√≥n actualizadas
--project-structure.md                # Estructura documentada
-+src/lib/requests.ts                 # Tipos corregidos, tabla 'invitations', campos alineados
-+src/components/RequestCard.tsx      # Propiedades de perfil corregidas (first_name, last_name)
-+reports/logic_check.md              # Auditor√≠a detallada con hallazgos ‚úÖ/‚ùå/‚ö†Ô∏è
-+reports/fix_plan.md                 # Plan de correcci√≥n con cronograma actualizado
-+reports/validation_checklist.md     # Checklist completo de QA y validaci√≥n
-+reports/logic_validation_checklist.md # Matriz de validaci√≥n de requisitos
-+dev-scripts/migrations.sql          # Script idempotente para completar BD
-+dev-scripts/rls.sql                 # Pol√≠ticas de seguridad granulares
-+diff.patch                          # Cambios de c√≥digo aplicados
-+audit_summary.json                  # Resumen ejecutivo completo
- ```
- 
-+### **Estado de Funcionalidades Post-Auditor√≠a**
-+- ‚úÖ **Landing Page**: Funcional sin autenticaci√≥n
-+- ‚úÖ **Sistema de Solicitudes**: Completamente operativo con tabla correcta
-+- ‚úÖ **Gesti√≥n de Perfiles**: Funcional con datos reales de Supabase
-+- ‚úÖ **Panel Admin**: Operativo con m√©tricas reales
-+- ‚ö†Ô∏è **Registro**: Funciona pero falta validaci√≥n email √∫nico
-+- ‚ùå **Sistema de Im√°genes**: Requiere ejecuci√≥n de migraciones
-+- ‚ùå **Pol√≠ticas RLS**: Scripts preparados pero no aplicados
-+- ‚ùå **Chat Real-time**: Requiere implementaci√≥n completa
-+
-+### **Pr√≥ximos Pasos Cr√≠ticos**
-+1. **Ejecutar** `dev-scripts/migrations.sql` en Supabase (10 min)
-+2. **Aplicar** `dev-scripts/rls.sql` para seguridad (5 min)
-+3. **Crear** buckets Storage: profile-images, gallery-images (15 min)
-+4. **Implementar** validaci√≥n email √∫nico en registro (30 min)
-+5. **Completar** sistema de im√°genes con permisos (2 horas)
-+
- ## üöÄ **Actualizaciones Previas v1.4.0** *(2 de septiembre, 2025 - 11:15)*
- 
- ### **Optimizaciones para APK Instalada**
-diff --git a/src/pages/Auth.tsx b/src/pages/Auth.tsx
-index 87d6b2c..9ccab36 100644
---- a/src/pages/Auth.tsx
-+++ b/src/pages/Auth.tsx
-@@ -299,6 +299,22 @@ const Auth = () => {
-     setIsLoading(true);
- 
-     try {
-+      // Verificar email √∫nico antes del registro
-+      const { data: existingProfile } = await supabase
-+        .from('profiles')
-+        .select('id')
-+        .eq('email', formData.email)
-+        .single();
-+
-+      if (existingProfile) {
-+        toast({
-+          variant: "destructive",
-+          title: "Email ya registrado",
-+          description: "Este email ya est√° en uso. Intenta iniciar sesi√≥n o usa otro email.",
-+        });
-+        return;
-+      }
-+
-       const redirectUrl = `${window.location.origin}/`;
-       
-       const { error } = await supabase.auth.signUp({
-diff --git a/src/pages/EditProfileSingle.tsx b/src/pages/EditProfileSingle.tsx
-index 56e1859..86e2248 100644
---- a/src/pages/EditProfileSingle.tsx
-+++ b/src/pages/EditProfileSingle.tsx
-@@ -7,7 +7,9 @@ import { Badge } from "@/components/ui/badge";
- import { ArrowLeft, Save, Upload, Plus, X, LogOut } from "lucide-react";
- import { useNavigate } from "react-router-dom";
- import { generateMockSingle } from "@/lib/data";
--import { ImageUpload } from "@/components/profile/ImageUpload";
-+import ImageUpload from "../components/ImageUpload";
-+import { supabase } from "../integrations/supabase/client";
-+import { appConfig } from "../lib/app-config";
- import Navigation from "@/components/Navigation";
- 
- const EditProfileSingle = () => {
-@@ -22,6 +24,10 @@ const EditProfileSingle = () => {
-     interests: [] as string[],
-     avatar: ""
-   });
-+  const [isLoading, setIsLoading] = useState(false);
-+  const [error, setError] = useState("");
-+  const [success, setSuccess] = useState("");
-+  const [userId, setUserId] = useState<string>("");
- 
-   const availableInterests = [
-     "Lifestyle Swinger", "Intercambio de Parejas", "Encuentros Casuales", "Comunicaci√≥n Abierta", 
-@@ -30,43 +36,102 @@ const EditProfileSingle = () => {
-   ];
- 
-   useEffect(() => {
--    // Verificar autenticaci√≥n (demo o producci√≥n)
--    const demoAuth = localStorage.getItem('demo_authenticated');
--    const demoUser = localStorage.getItem('demo_user');
--    
--    // Para producci√≥n: verificar autenticaci√≥n real con Supabase
--    // Para demo: usar datos locales
--    if (demoAuth === 'true' && demoUser) {
--      // Modo demo
--      const user = JSON.parse(demoUser);
--      let profileData;
--      
--      if (user.accountType === 'single') {
--        profileData = user;
-+    loadProfile();
-+  }, []);
-+
-+  const loadProfile = async () => {
-+    try {
-+      if (appConfig.features.demoCredentials) {
-+        // Modo demo
-+        const demoAuth = localStorage.getItem('demo_authenticated');
-+        const demoUser = localStorage.getItem('demo_user');
-+        
-+        if (demoAuth === 'true' && demoUser) {
-+          const user = JSON.parse(demoUser);
-+          let profileData;
-+          
-+          if (user.accountType === 'single') {
-+            profileData = user;
-+          } else {
-+            profileData = generateMockSingle();
-+          }
-+          
-+          setProfile(profileData);
-+          setUserId(user.id || 'demo-user');
-+          setFormData({
-+            name: profileData.name || "",
-+            age: profileData.age?.toString() || "",
-+            location: profileData.location || "",
-+            profession: profileData.profession || "",
-+            bio: profileData.bio || "",
-+            interests: profileData.interests || [],
-+            avatar: profileData.avatar || ""
-+          });
-+        }
-       } else {
--        profileData = generateMockSingle();
-+        // Modo producci√≥n - cargar desde Supabase
-+        const { data: { user } } = await supabase.auth.getUser();
-+        
-+        if (!user) {
-+          navigate('/auth');
-+          return;
-+        }
-+        
-+        setUserId(user.id);
-+        
-+        // Cargar perfil desde Supabase
-+        const { data: profileData, error } = await supabase
-+          .from('profiles')
-+          .select('*')
-+          .eq('id', user.id)
-+          .single();
-+        
-+        if (error && error.code !== 'PGRST116') {
-+          setError('Error al cargar perfil: ' + error.message);
-+          return;
-+        }
-+        
-+        if (profileData) {
-+          setProfile(profileData);
-+          setFormData({
-+            name: `${profileData.first_name} ${profileData.last_name}`.trim() || "",
-+            age: profileData.age?.toString() || "",
-+            location: "", // No location field in current schema
-+            profession: "", // No profession field in current schema
-+            bio: profileData.bio || "",
-+            interests: [], // No interests field in current schema
-+            avatar: "" // No avatar_url field in current schema
-+          });
-+        } else {
-+          // Crear perfil nuevo si no existe
-+          const newProfile = {
-+            id: user.id,
-+            first_name: user.user_metadata?.name?.split(' ')[0] || "Usuario",
-+            last_name: user.user_metadata?.name?.split(' ').slice(1).join(' ') || "",
-+            age: 25, // Default age
-+            gender: 'other',
-+            interested_in: 'all',
-+            user_id: user.id,
-+            created_at: new Date().toISOString()
-+          };
-+          
-+          const { error: insertError } = await supabase
-+            .from('profiles')
-+            .insert(newProfile);
-+          
-+          if (insertError) {
-+            setError('Error al crear perfil: ' + insertError.message);
-+          } else {
-+            setProfile(newProfile);
-+          }
-+        }
-       }
--      
--      setProfile(profileData);
--      setFormData({
--        name: profileData.name || '',
--        age: profileData.age?.toString() || '',
--        location: profileData.location || '',
--        profession: profileData.profession || '',
--        bio: profileData.bio || '',
--        interests: profileData.interests || [],
--        avatar: profileData.avatar || ''
--      });
--    } else {
--      // Modo producci√≥n: cargar datos reales del usuario desde Supabase
--      loadProductionProfile();
-+    } catch (error) {
-+      setError('Error inesperado al cargar perfil');
-+      console.error('Error loading profile:', error);
-+    } finally {
-+      console.log('Profile loaded');
-     }
--  }, [navigate]);
--
--  const loadProductionProfile = async () => {
--    // TODO: Implementar carga de perfil real desde Supabase
--    // Por ahora, redirigir a auth si no hay sesi√≥n demo
--    navigate('/auth');
-   };
- 
-   const handleInputChange = (field: string, value: string) => {
-@@ -85,9 +150,58 @@ const EditProfileSingle = () => {
-     }));
-   };
- 
--  const handleSave = () => {
--    console.log('Guardando perfil:', formData);
--    // Aqu√≠ ir√≠a la l√≥gica para guardar en Supabase
-+  const handleSave = async () => {
-+    if (isLoading) return;
-+    
-+    setIsLoading(true);
-+    setError('');
-+    setSuccess('');
-+    
-+    try {
-+      if (appConfig.features.demoCredentials) {
-+        // Modo demo - guardar en localStorage
-+        const demoUser = JSON.parse(localStorage.getItem('demo_user') || '{}');
-+        const updatedUser = {
-+          ...demoUser,
-+          ...formData,
-+          age: parseInt(formData.age) || undefined
-+        };
-+        localStorage.setItem('demo_user', JSON.stringify(updatedUser));
-+        setSuccess('Perfil guardado exitosamente (modo demo)');
-+      } else {
-+        // Modo producci√≥n - guardar en Supabase
-+        const nameParts = formData.name.split(' ');
-+        const { error } = await supabase
-+          .from('profiles')
-+          .update({
-+            first_name: nameParts[0] || '',
-+            last_name: nameParts.slice(1).join(' ') || '',
-+            age: parseInt(formData.age) || 25,
-+            bio: formData.bio,
-+            updated_at: new Date().toISOString()
-+          })
-+          .eq('id', userId);
-+        
-+        if (error) {
-+          setError('Error al guardar perfil: ' + error.message);
-+        } else {
-+          setSuccess('Perfil guardado exitosamente');
-+        }
-+      }
-+    } catch (error) {
-+      setError('Error inesperado al guardar perfil');
-+    } finally {
-+      setIsLoading(false);
-+    }
-+  };
-+  
-+  const handleImageUploaded = (url: string) => {
-+    setFormData(prev => ({ ...prev, avatar: url }));
-+    setSuccess('Imagen subida exitosamente');
-+  };
-+  
-+  const handleImageError = (error: string) => {
-+    setError(error);
-   };
- 
-   const handleLogout = () => {
-@@ -150,44 +264,31 @@ const EditProfileSingle = () => {
-       </div>
- 
-       <div className="p-4 pb-24 space-y-6">
--        <div className="space-y-6">
--          {/* Foto principal */}
--          <Card className="bg-white/10 backdrop-blur-md border-white/20 shadow-glow">
--            <CardContent className="p-6">
--              <h3 className="text-lg font-semibold text-white mb-4">Foto de Perfil</h3>
--              <ImageUpload
--                currentImage={formData.avatar}
--                onImageChange={(url) => setFormData(prev => ({ ...prev, avatar: url }))}
--                className="mb-4"
-+        {/* Informaci√≥n b√°sica */}
-+        <Card className="bg-white/10 backdrop-blur-md border-white/20 shadow-glow">
-+          <CardContent className="p-6 space-y-4">
-+            <h3 className="font-semibold text-white mb-4">Informaci√≥n b√°sica</h3>
-+            
-+            <div>
-+              <label className="block text-sm font-medium text-white mb-2">Nombre completo</label>
-+              <Input
-+                value={formData.name}
-+                onChange={(e) => handleInputChange('name', e.target.value)}
-+                placeholder="Tu nombre completo"
-+                className="bg-white/20 border-white/30 text-white placeholder:text-white/70"
-               />
--            </CardContent>
--          </Card>
--
--          {/* Informaci√≥n b√°sica */}
--          <Card className="bg-white/10 backdrop-blur-md border-white/20 shadow-glow">
--            <CardContent className="p-6 space-y-4">
--              <h3 className="font-semibold text-white mb-4">Informaci√≥n b√°sica</h3>
--              
--              <div>
--                <label className="block text-sm font-medium text-white mb-2">Nombre completo</label>
--                <Input
--                  value={formData.name}
--                  onChange={(e) => handleInputChange('name', e.target.value)}
--                  placeholder="Tu nombre completo"
--                  className="bg-white/20 border-white/30 text-white placeholder:text-white/70"
--                />
--              </div>
--              
--              <div>
--                <label className="block text-sm font-medium text-white mb-2">Edad</label>
--                <Input
--                  type="number"
--                  value={formData.age}
--                  onChange={(e) => handleInputChange('age', e.target.value)}
--                  placeholder="Tu edad"
--                  className="bg-white/20 border-white/30 text-white placeholder:text-white/70"
--                />
--              </div>
-+            </div>
-+            
-+            <div>
-+              <label className="block text-sm font-medium text-white mb-2">Edad</label>
-+              <Input
-+                type="number"
-+                value={formData.age}
-+                onChange={(e) => handleInputChange('age', e.target.value)}
-+                placeholder="Tu edad"
-+                className="bg-white/20 border-white/30 text-white placeholder:text-white/70"
-+              />
-+            </div>
-           </CardContent>
-         </Card>
- 
-@@ -285,11 +386,11 @@ const EditProfileSingle = () => {
-             </div>
-           </CardContent>
-         </Card>
--        </div>
-       </div>
- 
--      <Navigation />
-       </div>
-+
-+      <Navigation />
-       
-       {/* Custom Styles */}
-       <style>{`
diff --git a/package-lock.json b/package-lock.json
index dfadcea..14c52d8 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -41,7 +41,7 @@
         "@radix-ui/react-toggle-group": "^1.1.11",
         "@radix-ui/react-tooltip": "^1.2.8",
         "@rollup/wasm-node": "^4.9.2",
-        "@supabase/supabase-js": "^2.45.4",
+        "@supabase/supabase-js": "^2.57.2",
         "@tanstack/react-query": "^5.85.5",
         "@types/uuid": "^10.0.0",
         "@worldcoin/idkit": "^1.5.0",
@@ -68,6 +68,7 @@
         "supabase": "^2.39.2",
         "tailwind-merge": "^3.3.1",
         "tailwindcss-animate": "^1.0.7",
+        "tsx": "^4.20.5",
         "uuid": "^11.1.0",
         "vaul": "^1.1.2",
         "zod": "^4.1.5"
@@ -2432,7 +2433,9 @@
       }
     },
     "node_modules/@supabase/realtime-js": {
-      "version": "2.15.4",
+      "version": "2.15.5",
+      "resolved": "https://registry.npmjs.org/@supabase/realtime-js/-/realtime-js-2.15.5.tgz",
+      "integrity": "sha512-/Rs5Vqu9jejRD8ZeuaWXebdkH+J7V6VySbCZ/zQM93Ta5y3mAmocjioa/nzlB6qvFmyylUgKVS1KpE212t30OA==",
       "license": "MIT",
       "dependencies": {
         "@supabase/node-fetch": "^2.6.13",
@@ -2449,14 +2452,16 @@
       }
     },
     "node_modules/@supabase/supabase-js": {
-      "version": "2.56.1",
+      "version": "2.57.2",
+      "resolved": "https://registry.npmjs.org/@supabase/supabase-js/-/supabase-js-2.57.2.tgz",
+      "integrity": "sha512-MxaZqZKUPK1ExzOilgSZqCPCxVPjevUrh6bcWz1SrDZexFc9VJ2cJbVP1EG1hKQx/bfLdTUjIZMoIrYpYqAPYw==",
       "license": "MIT",
       "dependencies": {
         "@supabase/auth-js": "2.71.1",
         "@supabase/functions-js": "2.4.5",
         "@supabase/node-fetch": "2.6.15",
         "@supabase/postgrest-js": "1.21.3",
-        "@supabase/realtime-js": "2.15.4",
+        "@supabase/realtime-js": "2.15.5",
         "@supabase/storage-js": "^2.10.4"
       }
     },
@@ -2615,6 +2620,8 @@
     },
     "node_modules/@types/phoenix": {
       "version": "1.6.6",
+      "resolved": "https://registry.npmjs.org/@types/phoenix/-/phoenix-1.6.6.tgz",
+      "integrity": "sha512-PIzZZlEppgrpoT2QgbnDU+MMzuR6BbCjllj0bM70lWoejMeNJAxCchxnv7J3XFkI8MpygtRpzXrIlmWUBclP5A==",
       "license": "MIT"
     },
     "node_modules/@types/react": {
@@ -2664,6 +2671,8 @@
     },
     "node_modules/@types/ws": {
       "version": "8.18.1",
+      "resolved": "https://registry.npmjs.org/@types/ws/-/ws-8.18.1.tgz",
+      "integrity": "sha512-ThVF6DCVhA8kUGy+aazFQ4kXQ7E1Ty7A3ypFOe0IcJV8O/M511G99AW24irKrW56Wt44yG9+ij8FaqoBGkuBXg==",
       "license": "MIT",
       "dependencies": {
         "@types/node": "*"
@@ -3871,7 +3880,6 @@
     },
     "node_modules/esbuild": {
       "version": "0.25.9",
-      "dev": true,
       "hasInstallScript": true,
       "license": "MIT",
       "bin": {
@@ -4403,6 +4411,18 @@
         "node": ">=6"
       }
     },
+    "node_modules/get-tsconfig": {
+      "version": "4.10.1",
+      "resolved": "https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.10.1.tgz",
+      "integrity": "sha512-auHyJ4AgMz7vgS8Hp3N6HXSmlMdUyhSUrfBF16w153rxtLIEOE+HGqaBppczZvnHLqQJfiHotCYpNhl0lUROFQ==",
+      "license": "MIT",
+      "dependencies": {
+        "resolve-pkg-maps": "^1.0.0"
+      },
+      "funding": {
+        "url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
+      }
+    },
     "node_modules/glob": {
       "version": "11.0.3",
       "license": "ISC",
@@ -6158,6 +6178,15 @@
         "node": ">=4"
       }
     },
+    "node_modules/resolve-pkg-maps": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/resolve-pkg-maps/-/resolve-pkg-maps-1.0.0.tgz",
+      "integrity": "sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==",
+      "license": "MIT",
+      "funding": {
+        "url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
+      }
+    },
     "node_modules/reusify": {
       "version": "1.1.0",
       "dev": true,
@@ -6868,6 +6897,25 @@
       "version": "2.8.1",
       "license": "0BSD"
     },
+    "node_modules/tsx": {
+      "version": "4.20.5",
+      "resolved": "https://registry.npmjs.org/tsx/-/tsx-4.20.5.tgz",
+      "integrity": "sha512-+wKjMNU9w/EaQayHXb7WA7ZaHY6hN8WgfvHNQ3t1PnU91/7O8TcTnIhCDYTZwnt8JsO9IBqZ30Ln1r7pPF52Aw==",
+      "license": "MIT",
+      "dependencies": {
+        "esbuild": "~0.25.0",
+        "get-tsconfig": "^4.7.5"
+      },
+      "bin": {
+        "tsx": "dist/cli.mjs"
+      },
+      "engines": {
+        "node": ">=18.0.0"
+      },
+      "optionalDependencies": {
+        "fsevents": "~2.3.3"
+      }
+    },
     "node_modules/type-check": {
       "version": "0.4.0",
       "dev": true,
@@ -7300,6 +7348,8 @@
     },
     "node_modules/ws": {
       "version": "8.18.3",
+      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
+      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
       "license": "MIT",
       "engines": {
         "node": ">=10.0.0"
diff --git a/package.json b/package.json
index 701f2c4..ae76942 100644
--- a/package.json
+++ b/package.json
@@ -48,7 +48,7 @@
     "@radix-ui/react-toggle-group": "^1.1.11",
     "@radix-ui/react-tooltip": "^1.2.8",
     "@rollup/wasm-node": "^4.9.2",
-    "@supabase/supabase-js": "^2.45.4",
+    "@supabase/supabase-js": "^2.57.2",
     "@tanstack/react-query": "^5.85.5",
     "@types/uuid": "^10.0.0",
     "@worldcoin/idkit": "^1.5.0",
@@ -75,6 +75,7 @@
     "supabase": "^2.39.2",
     "tailwind-merge": "^3.3.1",
     "tailwindcss-animate": "^1.0.7",
+    "tsx": "^4.20.5",
     "uuid": "^11.1.0",
     "vaul": "^1.1.2",
     "zod": "^4.1.5"
diff --git a/scripts/execute-migrations.js b/scripts/execute-migrations.js
new file mode 100644
index 0000000..dda1568
--- /dev/null
+++ b/scripts/execute-migrations.js
@@ -0,0 +1,193 @@
+const { createClient } = require('@supabase/supabase-js');
+const fs = require('fs');
+const path = require('path');
+
+// Configuraci√≥n de Supabase
+const supabaseUrl = 'https://axtvqnozatbmllvwzuim.supabase.co';
+const supabaseServiceKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF4dHZxbm96YXRibWxsdnd6dWltIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NjA4NDkwNiwiZXhwIjoyMDYxNjYwOTA2fQ.KvAcO_zk5zriEzRzq6AS2sTtqeWB5K_RN3Xr0ZYsGMw';
+
+const supabase = createClient(supabaseUrl, supabaseServiceKey);
+
+async function executeSQL(sql, description) {
+  console.log(`üìÑ Ejecutando ${description}...`);
+  
+  try {
+    // Usar fetch directo para ejecutar SQL
+    const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec_sql`, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+        'Authorization': `Bearer ${supabaseServiceKey}`,
+        'apikey': supabaseServiceKey
+      },
+      body: JSON.stringify({ sql })
+    });
+
+    if (!response.ok) {
+      const error = await response.text();
+      console.error(`‚ùå Error HTTP ${response.status}:`, error);
+      return false;
+    }
+
+    console.log(`‚úÖ ${description} ejecutado exitosamente`);
+    return true;
+  } catch (error) {
+    console.error(`üí• Error ejecutando ${description}:`, error.message);
+    return false;
+  }
+}
+
+async function createTablesManually() {
+  console.log('üîß Creando tablas manualmente...');
+  
+  // Crear tabla images
+  const createImagesTable = `
+    CREATE TABLE IF NOT EXISTS images (
+      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
+      profile_id TEXT NOT NULL,
+      url TEXT NOT NULL,
+      is_public BOOLEAN DEFAULT true,
+      description TEXT,
+      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
+      updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
+    );
+  `;
+  
+  // Crear tabla chat_rooms
+  const createChatRoomsTable = `
+    CREATE TABLE IF NOT EXISTS chat_rooms (
+      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
+      name TEXT NOT NULL,
+      description TEXT,
+      is_public BOOLEAN DEFAULT false,
+      is_active BOOLEAN DEFAULT true,
+      created_by TEXT NOT NULL,
+      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
+      updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
+    );
+  `;
+  
+  // Crear tabla messages
+  const createMessagesTable = `
+    CREATE TABLE IF NOT EXISTS messages (
+      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
+      room_id UUID REFERENCES chat_rooms(id) ON DELETE CASCADE,
+      sender_id TEXT NOT NULL,
+      content TEXT NOT NULL,
+      message_type TEXT DEFAULT 'text',
+      is_deleted BOOLEAN DEFAULT false,
+      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
+      updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
+    );
+  `;
+  
+  // Crear tabla chat_members
+  const createChatMembersTable = `
+    CREATE TABLE IF NOT EXISTS chat_members (
+      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
+      room_id UUID REFERENCES chat_rooms(id) ON DELETE CASCADE,
+      profile_id TEXT NOT NULL,
+      role TEXT DEFAULT 'member',
+      is_muted BOOLEAN DEFAULT false,
+      joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
+      UNIQUE(room_id, profile_id)
+    );
+  `;
+  
+  // Crear tabla image_permissions
+  const createImagePermissionsTable = `
+    CREATE TABLE IF NOT EXISTS image_permissions (
+      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
+      image_id UUID REFERENCES images(id) ON DELETE CASCADE,
+      granted_to TEXT NOT NULL,
+      granted_by TEXT NOT NULL,
+      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
+      UNIQUE(image_id, granted_to)
+    );
+  `;
+  
+  const tables = [
+    { sql: createImagesTable, name: 'images' },
+    { sql: createChatRoomsTable, name: 'chat_rooms' },
+    { sql: createMessagesTable, name: 'messages' },
+    { sql: createChatMembersTable, name: 'chat_members' },
+    { sql: createImagePermissionsTable, name: 'image_permissions' }
+  ];
+  
+  for (const table of tables) {
+    const success = await executeSQL(table.sql, `tabla ${table.name}`);
+    if (!success) {
+      console.error(`‚ùå Fall√≥ la creaci√≥n de tabla ${table.name}`);
+      return false;
+    }
+  }
+  
+  return true;
+}
+
+async function testConnection() {
+  console.log('üîç Probando conexi√≥n a Supabase...');
+  
+  try {
+    const { data, error } = await supabase
+      .from('profiles')
+      .select('count')
+      .limit(1);
+    
+    if (error) {
+      console.log('‚ö†Ô∏è  Error de conexi√≥n:', error.message);
+      return false;
+    }
+    
+    console.log('‚úÖ Conexi√≥n a Supabase exitosa');
+    return true;
+  } catch (err) {
+    console.error('‚ùå Error de conexi√≥n:', err.message);
+    return false;
+  }
+}
+
+async function runMigrations() {
+  console.log('üöÄ Iniciando migraciones ComplicesConecta v1.9.0');
+  console.log('üìÖ Fecha:', new Date().toLocaleString('es-MX'));
+  
+  // Probar conexi√≥n
+  const connected = await testConnection();
+  if (!connected) {
+    console.error('üí• No se pudo conectar a Supabase');
+    process.exit(1);
+  }
+  
+  // Crear tablas manualmente
+  const tablesCreated = await createTablesManually();
+  if (!tablesCreated) {
+    console.error('üí• Fall√≥ la creaci√≥n de tablas');
+    process.exit(1);
+  }
+  
+  // Verificar tablas creadas
+  console.log('üîç Verificando tablas...');
+  const tablesToCheck = ['images', 'chat_rooms', 'messages', 'chat_members', 'image_permissions'];
+  
+  for (const tableName of tablesToCheck) {
+    try {
+      const { data, error } = await supabase
+        .from(tableName)
+        .select('*')
+        .limit(1);
+      
+      if (error && !error.message.includes('relation') && !error.message.includes('does not exist')) {
+        console.log(`‚ö†Ô∏è  Tabla ${tableName}: ${error.message}`);
+      } else {
+        console.log(`‚úÖ Tabla ${tableName}: Creada correctamente`);
+      }
+    } catch (err) {
+      console.log(`‚ùå Tabla ${tableName}: ${err.message}`);
+    }
+  }
+  
+  console.log('üéâ Migraciones b√°sicas completadas!');
+  console.log('üìã Siguiente: Aplicar pol√≠ticas RLS y crear buckets de Storage');
+}
+
+runMigrations().catch(console.error);
diff --git a/scripts/migrate.js b/scripts/migrate.js
new file mode 100644
index 0000000..9de519d
--- /dev/null
+++ b/scripts/migrate.js
@@ -0,0 +1,84 @@
+const { createClient } = require('@supabase/supabase-js');
+const fs = require('fs');
+const path = require('path');
+
+// Configuraci√≥n de Supabase
+const supabaseUrl = 'https://axtvqnozatbmllvwzuim.supabase.co';
+const supabaseServiceKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF4dHZxbm96YXRibWxsdnd6dWltIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NjA4NDkwNiwiZXhwIjoyMDYxNjYwOTA2fQ.KvAcO_zk5zriEzRzq6AS2sTtqeWB5K_RN3Xr0ZYsGMw';
+
+const supabase = createClient(supabaseUrl, supabaseServiceKey);
+
+async function executeSQLFile(filePath, description) {
+  console.log(`üìÑ Ejecutando ${description}...`);
+  
+  try {
+    const sqlContent = fs.readFileSync(filePath, 'utf8');
+    
+    // Ejecutar el SQL completo usando rpc
+    const { data, error } = await supabase.rpc('exec_sql', { 
+      sql: sqlContent 
+    });
+    
+    if (error) {
+      console.error(`‚ùå Error en ${description}:`, error.message);
+      return false;
+    }
+    
+    console.log(`‚úÖ ${description} ejecutado exitosamente`);
+    return true;
+  } catch (err) {
+    console.error(`üí• Error leyendo ${filePath}:`, err.message);
+    return false;
+  }
+}
+
+async function runMigrations() {
+  console.log('üöÄ Iniciando migraciones ComplicesConecta v1.9.0...');
+  console.log('üìÖ Fecha:', new Date().toLocaleString('es-MX'));
+  
+  // Ejecutar migraciones
+  const migrationsPath = path.join(__dirname, '..', 'dev-scripts', 'migrations.sql');
+  const migrationsSuccess = await executeSQLFile(migrationsPath, 'migrations.sql');
+  
+  if (!migrationsSuccess) {
+    console.error('üí• Fall√≥ la ejecuci√≥n de migraciones');
+    process.exit(1);
+  }
+  
+  // Ejecutar pol√≠ticas RLS
+  const rlsPath = path.join(__dirname, '..', 'dev-scripts', 'rls.sql');
+  const rlsSuccess = await executeSQLFile(rlsPath, 'rls.sql (pol√≠ticas de seguridad)');
+  
+  if (!rlsSuccess) {
+    console.error('üí• Fall√≥ la aplicaci√≥n de pol√≠ticas RLS');
+    process.exit(1);
+  }
+  
+  // Verificar tablas creadas
+  console.log('üîç Verificando tablas creadas...');
+  
+  const tablesToCheck = ['profiles', 'images', 'chat_rooms', 'messages', 'chat_members', 'invitations'];
+  
+  for (const tableName of tablesToCheck) {
+    try {
+      const { data, error } = await supabase
+        .from(tableName)
+        .select('*')
+        .limit(1);
+      
+      if (error && error.code !== 'PGRST116') { // PGRST116 = tabla vac√≠a, est√° bien
+        console.log(`‚ö†Ô∏è  Tabla ${tableName}: ${error.message}`);
+      } else {
+        console.log(`‚úÖ Tabla ${tableName}: OK`);
+      }
+    } catch (err) {
+      console.log(`‚ùå Tabla ${tableName}: Error - ${err.message}`);
+    }
+  }
+  
+  console.log('üéâ Migraciones completadas exitosamente!');
+  console.log('üìã Pr√≥ximo paso: Crear buckets de Storage en Supabase Dashboard');
+}
+
+// Ejecutar migraciones
+runMigrations().catch(console.error);
diff --git a/scripts/run-migrations.ts b/scripts/run-migrations.ts
new file mode 100644
index 0000000..3e9d942
--- /dev/null
+++ b/scripts/run-migrations.ts
@@ -0,0 +1,88 @@
+import { createClient } from '@supabase/supabase-js'
+import { readFileSync } from 'fs'
+import { join } from 'path'
+
+// Configuraci√≥n de Supabase
+const supabaseUrl = 'https://axtvqnozatbmllvwzuim.supabase.co'
+const supabaseServiceKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF4dHZxbm96YXRibWxsdnd6dWltIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0NjA4NDkwNiwiZXhwIjoyMDYxNjYwOTA2fQ.KvAcO_zk5zriEzRzq6AS2sTtqeWB5K_RN3Xr0ZYsGMw'
+
+const supabase = createClient(supabaseUrl, supabaseServiceKey)
+
+async function runMigrations() {
+  console.log('üöÄ Iniciando migraciones de ComplicesConecta v1.9.0...')
+  
+  try {
+    // Leer archivo de migraciones
+    const migrationsPath = join(process.cwd(), 'dev-scripts', 'migrations.sql')
+    const migrationsSQL = readFileSync(migrationsPath, 'utf8')
+    
+    console.log('üìÑ Ejecutando migrations.sql...')
+    
+    // Dividir el SQL en statements individuales
+    const statements = migrationsSQL
+      .split(';')
+      .map(s => s.trim())
+      .filter(s => s.length > 0 && !s.startsWith('--'))
+    
+    for (const statement of statements) {
+      if (statement.trim()) {
+        const { error } = await supabase.rpc('exec_sql', { sql: statement })
+        if (error) {
+          console.error('‚ùå Error ejecutando statement:', error.message)
+          console.log('Statement:', statement.substring(0, 100) + '...')
+        }
+      }
+    }
+    
+    console.log('‚úÖ Migraciones ejecutadas exitosamente')
+    
+    // Leer archivo de RLS
+    const rlsPath = join(process.cwd(), 'dev-scripts', 'rls.sql')
+    const rlsSQL = readFileSync(rlsPath, 'utf8')
+    
+    console.log('üîí Ejecutando pol√≠ticas RLS...')
+    
+    const rlsStatements = rlsSQL
+      .split(';')
+      .map(s => s.trim())
+      .filter(s => s.length > 0 && !s.startsWith('--'))
+    
+    for (const statement of rlsStatements) {
+      if (statement.trim()) {
+        const { error } = await supabase.rpc('exec_sql', { sql: statement })
+        if (error) {
+          console.error('‚ùå Error ejecutando RLS:', error.message)
+          console.log('Statement:', statement.substring(0, 100) + '...')
+        }
+      }
+    }
+    
+    console.log('‚úÖ Pol√≠ticas RLS aplicadas exitosamente')
+    
+    // Verificar tablas creadas
+    const { data: tables, error: tablesError } = await supabase
+      .from('information_schema.tables')
+      .select('table_name')
+      .eq('table_schema', 'public')
+      .in('table_name', ['images', 'chat_rooms', 'messages', 'chat_members', 'image_permissions'])
+    
+    if (tablesError) {
+      console.error('‚ùå Error verificando tablas:', tablesError.message)
+    } else {
+      console.log('üìä Tablas verificadas:', tables?.map(t => t.table_name).join(', '))
+    }
+    
+    console.log('üéâ Migraciones completadas exitosamente!')
+    
+  } catch (error) {
+    console.error('üí• Error ejecutando migraciones:', error)
+    process.exit(1)
+  }
+}
+
+// Ejecutar si es llamado directamente
+if (require.main === module) {
+  runMigrations()
+}
+
+export { runMigrations }
diff --git a/src/integrations/supabase/types.ts b/src/integrations/supabase/types.ts
index cf28f8e..ff8060c 100644
--- a/src/integrations/supabase/types.ts
+++ b/src/integrations/supabase/types.ts
@@ -38,6 +38,245 @@ export type Database = {
         }
         Relationships: []
       }
+      chat_invitations: {
+        Row: {
+          created_at: string
+          from_profile: string
+          id: string
+          room_id: string
+          status: string
+          to_profile: string
+          updated_at: string
+        }
+        Insert: {
+          created_at?: string
+          from_profile: string
+          id?: string
+          room_id: string
+          status?: string
+          to_profile: string
+          updated_at?: string
+        }
+        Update: {
+          created_at?: string
+          from_profile?: string
+          id?: string
+          room_id?: string
+          status?: string
+          to_profile?: string
+          updated_at?: string
+        }
+        Relationships: [
+          {
+            foreignKeyName: "chat_invitations_room_id_fkey"
+            columns: ["room_id"]
+            isOneToOne: false
+            referencedRelation: "chat_rooms"
+            referencedColumns: ["id"]
+          }
+        ]
+      }
+      chat_members: {
+        Row: {
+          id: string
+          is_muted: boolean
+          joined_at: string
+          profile_id: string
+          role: string
+          room_id: string
+        }
+        Insert: {
+          id?: string
+          is_muted?: boolean
+          joined_at?: string
+          profile_id: string
+          role?: string
+          room_id: string
+        }
+        Update: {
+          id?: string
+          is_muted?: boolean
+          joined_at?: string
+          profile_id?: string
+          role?: string
+          room_id?: string
+        }
+        Relationships: [
+          {
+            foreignKeyName: "chat_members_room_id_fkey"
+            columns: ["room_id"]
+            isOneToOne: false
+            referencedRelation: "chat_rooms"
+            referencedColumns: ["id"]
+          }
+        ]
+      }
+      chat_rooms: {
+        Row: {
+          created_at: string
+          created_by: string
+          description: string | null
+          id: string
+          is_active: boolean
+          is_public: boolean
+          name: string
+          updated_at: string
+        }
+        Insert: {
+          created_at?: string
+          created_by: string
+          description?: string | null
+          id?: string
+          is_active?: boolean
+          is_public?: boolean
+          name: string
+          updated_at?: string
+        }
+        Update: {
+          created_at?: string
+          created_by?: string
+          description?: string | null
+          id?: string
+          is_active?: boolean
+          is_public?: boolean
+          name?: string
+          updated_at?: string
+        }
+        Relationships: []
+      }
+      gallery_access_requests: {
+        Row: {
+          created_at: string
+          from_profile: string
+          id: string
+          message: string | null
+          status: string
+          to_profile: string
+          updated_at: string
+        }
+        Insert: {
+          created_at?: string
+          from_profile: string
+          id?: string
+          message?: string | null
+          status?: string
+          to_profile: string
+          updated_at?: string
+        }
+        Update: {
+          created_at?: string
+          from_profile?: string
+          id?: string
+          message?: string | null
+          status?: string
+          to_profile?: string
+          updated_at?: string
+        }
+        Relationships: []
+      }
+      image_permissions: {
+        Row: {
+          created_at: string
+          granted_by: string
+          granted_to: string
+          id: string
+          image_id: string
+        }
+        Insert: {
+          created_at?: string
+          granted_by: string
+          granted_to: string
+          id?: string
+          image_id: string
+        }
+        Update: {
+          created_at?: string
+          granted_by?: string
+          granted_to?: string
+          id?: string
+          image_id?: string
+        }
+        Relationships: [
+          {
+            foreignKeyName: "image_permissions_image_id_fkey"
+            columns: ["image_id"]
+            isOneToOne: false
+            referencedRelation: "images"
+            referencedColumns: ["id"]
+          }
+        ]
+      }
+      images: {
+        Row: {
+          created_at: string
+          description: string | null
+          id: string
+          is_public: boolean
+          profile_id: string
+          updated_at: string
+          url: string
+        }
+        Insert: {
+          created_at?: string
+          description?: string | null
+          id?: string
+          is_public?: boolean
+          profile_id: string
+          updated_at?: string
+          url: string
+        }
+        Update: {
+          created_at?: string
+          description?: string | null
+          id?: string
+          is_public?: boolean
+          profile_id?: string
+          updated_at?: string
+          url?: string
+        }
+        Relationships: []
+      }
+      messages: {
+        Row: {
+          content: string
+          created_at: string
+          id: string
+          is_deleted: boolean
+          message_type: string
+          room_id: string
+          sender_id: string
+          updated_at: string
+        }
+        Insert: {
+          content: string
+          created_at?: string
+          id?: string
+          is_deleted?: boolean
+          message_type?: string
+          room_id: string
+          sender_id: string
+          updated_at?: string
+        }
+        Update: {
+          content?: string
+          created_at?: string
+          id?: string
+          is_deleted?: boolean
+          message_type?: string
+          room_id?: string
+          sender_id?: string
+          updated_at?: string
+        }
+        Relationships: [
+          {
+            foreignKeyName: "messages_room_id_fkey"
+            columns: ["room_id"]
+            isOneToOne: false
+            referencedRelation: "chat_rooms"
+            referencedColumns: ["id"]
+          }
+        ]
+      }
       app_metrics: {
         Row: {
           created_at: string | null
diff --git a/src/lib/chat.ts b/src/lib/chat.ts
index 0b902bc..0bfc2d5 100644
--- a/src/lib/chat.ts
+++ b/src/lib/chat.ts
@@ -1,5 +1,24 @@
-// SERVICIO TEMPORAL DE CHAT
-// Este archivo ser√° reemplazado cuando se ejecuten las migraciones de BD
+/**
+ * SERVICIO DE CHAT REAL-TIME - ComplicesConecta
+ * 
+ * Sistema completo de chat con soporte para:
+ * - Salas p√∫blicas y privadas
+ * - Mensajes en tiempo real con Supabase Realtime
+ * - Invitaciones y permisos de acceso
+ * - Multimedia (texto, im√°genes, archivos)
+ */
+
+import { supabase } from '@/integrations/supabase/client';
+import type { Database } from '@/integrations/supabase/types';
+
+type ChatRoomRow = Database['public']['Tables']['chat_rooms']['Row'];
+type ChatRoomInsert = Database['public']['Tables']['chat_rooms']['Insert'];
+type ChatMemberRow = Database['public']['Tables']['chat_members']['Row'];
+type ChatMemberInsert = Database['public']['Tables']['chat_members']['Insert'];
+type MessageRow = Database['public']['Tables']['messages']['Row'];
+type MessageInsert = Database['public']['Tables']['messages']['Insert'];
+type ChatInvitationRow = Database['public']['Tables']['chat_invitations']['Row'];
+type ChatInvitationInsert = Database['public']['Tables']['chat_invitations']['Insert'];
 
 export interface ChatRoom {
   id: string;
@@ -8,6 +27,8 @@ export interface ChatRoom {
   created_by: string;
   created_at: string;
   updated_at: string;
+  description?: string;
+  is_active: boolean;
 }
 
 export interface ChatMember {
@@ -16,6 +37,7 @@ export interface ChatMember {
   profile_id: string;
   joined_at: string;
   role: 'admin' | 'member';
+  is_muted: boolean;
 }
 
 export interface ChatMessage {
@@ -25,6 +47,7 @@ export interface ChatMessage {
   content: string;
   message_type: 'text' | 'image' | 'file';
   created_at: string;
+  is_deleted: boolean;
   sender_profile?: {
     id: string;
     first_name: string;
@@ -36,107 +59,536 @@ export interface ChatMessage {
 export interface ChatInvitation {
   id: string;
   room_id: string;
-  inviter_id: string;
-  invitee_id: string;
+  from_profile: string;
+  to_profile: string;
   status: 'pending' | 'accepted' | 'declined';
   created_at: string;
-  decided_at?: string;
+  updated_at: string;
 }
 
 class ChatService {
   private subscriptions: Map<string, any> = new Map();
 
   /**
-   * VERSI√ìN TEMPORAL - Retorna error hasta que se ejecuten migraciones
+   * Obtiene o crea la sala p√∫blica principal
    */
   async getPublicRoom(): Promise<{ success: boolean; room?: ChatRoom; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      // Buscar sala p√∫blica existente
+      const { data: existingRoom, error: searchError } = await supabase
+        .from('chat_rooms')
+        .select('*')
+        .eq('is_public', true)
+        .eq('is_active', true)
+        .single();
+
+      if (existingRoom && !searchError) {
+        return {
+          success: true,
+          room: mapChatRoomRowToChatRoom(existingRoom)
+        };
+      }
+
+      // Crear sala p√∫blica si no existe
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) {
+        return { success: false, error: 'Usuario no autenticado' };
+      }
+
+      const roomData: ChatRoomInsert = {
+        name: 'Chat P√∫blico',
+        description: 'Sala de chat p√∫blica para todos los usuarios',
+        is_public: true,
+        is_active: true,
+        created_by: user.user.id
+      };
+
+      const { data: newRoom, error: createError } = await supabase
+        .from('chat_rooms')
+        .insert(roomData)
+        .select()
+        .single();
+
+      if (createError || !newRoom) {
+        return { success: false, error: `Error al crear sala p√∫blica: ${createError?.message}` };
+      }
+
+      return {
+        success: true,
+        room: mapChatRoomRowToChatRoom(newRoom)
+      };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 
+  /**
+   * Crea una sala privada con miembros espec√≠ficos
+   */
   async createPrivateRoom(
     name: string,
     memberIds: string[]
   ): Promise<{ success: boolean; room?: ChatRoom; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) {
+        return { success: false, error: 'Usuario no autenticado' };
+      }
+
+      // Crear sala privada
+      const roomData: ChatRoomInsert = {
+        name,
+        is_public: false,
+        is_active: true,
+        created_by: user.user.id
+      };
+
+      const { data: newRoom, error: roomError } = await supabase
+        .from('chat_rooms')
+        .insert(roomData)
+        .select()
+        .single();
+
+      if (roomError || !newRoom) {
+        return { success: false, error: `Error al crear sala: ${roomError?.message}` };
+      }
+
+      // Agregar creador como admin
+      const creatorMember: ChatMemberInsert = {
+        room_id: newRoom.id,
+        profile_id: user.user.id,
+        role: 'admin',
+        is_muted: false
+      };
+
+      await supabase.from('chat_members').insert(creatorMember);
+
+      // Agregar otros miembros
+      const memberInserts: ChatMemberInsert[] = memberIds.map(memberId => ({
+        room_id: newRoom.id,
+        profile_id: memberId,
+        role: 'member',
+        is_muted: false
+      }));
+
+      if (memberInserts.length > 0) {
+        await supabase.from('chat_members').insert(memberInserts);
+      }
+
+      return {
+        success: true,
+        room: mapChatRoomRowToChatRoom(newRoom)
+      };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 
+  /**
+   * Obtiene las salas de chat del usuario actual
+   */
   async getUserRooms(): Promise<{ success: boolean; rooms?: ChatRoom[]; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) {
+        return { success: false, error: 'Usuario no autenticado' };
+      }
+
+      // Obtener salas p√∫blicas y privadas donde el usuario es miembro
+      const { data: rooms, error } = await supabase
+        .from('chat_rooms')
+        .select(`
+          *,
+          chat_members!inner(profile_id)
+        `)
+        .or(`is_public.eq.true,chat_members.profile_id.eq.${user.user.id}`)
+        .eq('is_active', true)
+        .order('updated_at', { ascending: false });
+
+      if (error) {
+        return { success: false, error: `Error al obtener salas: ${error.message}` };
+      }
+
+      return {
+        success: true,
+        rooms: rooms.map(mapChatRoomRowToChatRoom)
+      };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 
+  /**
+   * Env√≠a un mensaje a una sala
+   */
   async sendMessage(
     roomId: string,
     content: string,
     messageType: 'text' | 'image' | 'file' = 'text'
   ): Promise<{ success: boolean; message?: ChatMessage; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) {
+        return { success: false, error: 'Usuario no autenticado' };
+      }
+
+      // Verificar acceso a la sala
+      const hasAccess = await this.canAccessRoom(roomId);
+      if (!hasAccess) {
+        return { success: false, error: 'Sin permisos para acceder a esta sala' };
+      }
+
+      const messageData: MessageInsert = {
+        room_id: roomId,
+        sender_id: user.user.id,
+        content,
+        message_type: messageType,
+        is_deleted: false
+      };
+
+      const { data: newMessage, error } = await supabase
+        .from('messages')
+        .insert(messageData)
+        .select()
+        .single();
+
+      if (error || !newMessage) {
+        return { success: false, error: `Error al enviar mensaje: ${error?.message}` };
+      }
+
+      return {
+        success: true,
+        message: mapMessageRowToChatMessage(newMessage)
+      };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 
+  /**
+   * Obtiene mensajes de una sala
+   */
   async getRoomMessages(
     roomId: string,
     limit: number = 50
   ): Promise<{ success: boolean; messages?: ChatMessage[]; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      // Verificar acceso a la sala
+      const hasAccess = await this.canAccessRoom(roomId);
+      if (!hasAccess) {
+        return { success: false, error: 'Sin permisos para acceder a esta sala' };
+      }
+
+      const { data: messages, error } = await supabase
+        .from('messages')
+        .select(`
+          *,
+          profiles:sender_id(id, first_name, last_name)
+        `)
+        .eq('room_id', roomId)
+        .eq('is_deleted', false)
+        .order('created_at', { ascending: false })
+        .limit(limit);
+
+      if (error) {
+        return { success: false, error: `Error al obtener mensajes: ${error.message}` };
+      }
+
+      return {
+        success: true,
+        messages: messages.map(mapMessageRowToChatMessage).reverse()
+      };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 
+  /**
+   * Suscribe a mensajes en tiempo real de una sala
+   */
   subscribeToRoom(roomId: string, callback: (message: ChatMessage) => void): () => void {
-    console.warn('Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)');
-    return () => {};
+    const subscription = supabase
+      .channel(`room:${roomId}`)
+      .on(
+        'postgres_changes',
+        {
+          event: 'INSERT',
+          schema: 'public',
+          table: 'messages',
+          filter: `room_id=eq.${roomId}`
+        },
+        async (payload) => {
+          const newMessage = payload.new as MessageRow;
+          const mappedMessage = mapMessageRowToChatMessage(newMessage);
+          
+          // Obtener informaci√≥n del perfil del remitente
+          const { data: profile } = await supabase
+            .from('profiles')
+            .select('id, first_name, last_name')
+            .eq('id', newMessage.sender_id)
+            .single();
+
+          if (profile) {
+            mappedMessage.sender_profile = {
+              id: profile.id,
+              first_name: profile.first_name,
+              last_name: profile.last_name
+            };
+          }
+
+          callback(mappedMessage);
+        }
+      )
+      .subscribe();
+
+    this.subscriptions.set(roomId, subscription);
+
+    return () => {
+      subscription.unsubscribe();
+      this.subscriptions.delete(roomId);
+    };
   }
 
+  /**
+   * Cancela suscripci√≥n a una sala
+   */
   unsubscribeFromRoom(roomId: string): void {
-    console.warn('Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)');
+    const subscription = this.subscriptions.get(roomId);
+    if (subscription) {
+      subscription.unsubscribe();
+      this.subscriptions.delete(roomId);
+    }
   }
 
+  /**
+   * Verifica si el usuario puede acceder a una sala
+   */
   async canAccessRoom(roomId: string): Promise<boolean> {
-    return false;
+    try {
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) return false;
+
+      // Obtener informaci√≥n de la sala
+      const { data: room, error: roomError } = await supabase
+        .from('chat_rooms')
+        .select('is_public, created_by')
+        .eq('id', roomId)
+        .single();
+
+      if (roomError || !room) return false;
+
+      // Si es p√∫blica, todos tienen acceso
+      if (room.is_public) return true;
+
+      // Si es el creador, tiene acceso
+      if (room.created_by === user.user.id) return true;
+
+      // Verificar si es miembro
+      const { data: member, error: memberError } = await supabase
+        .from('chat_members')
+        .select('id')
+        .eq('room_id', roomId)
+        .eq('profile_id', user.user.id)
+        .single();
+
+      return !memberError && !!member;
+
+    } catch (error) {
+      console.error('Error al verificar acceso a sala:', error);
+      return false;
+    }
   }
 
+  /**
+   * Invita a un usuario a una sala privada
+   */
   async inviteToRoom(
     roomId: string,
-    inviteeId: string
+    toProfileId: string
   ): Promise<{ success: boolean; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) {
+        return { success: false, error: 'Usuario no autenticado' };
+      }
+
+      const invitationData: ChatInvitationInsert = {
+        room_id: roomId,
+        from_profile: user.user.id,
+        to_profile: toProfileId,
+        status: 'pending'
+      };
+
+      const { error } = await supabase
+        .from('chat_invitations')
+        .insert(invitationData);
+
+      if (error) {
+        return { success: false, error: `Error al enviar invitaci√≥n: ${error.message}` };
+      }
+
+      return { success: true };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 
+  /**
+   * Responde a una invitaci√≥n de chat
+   */
   async respondToInvitation(
     invitationId: string,
     accept: boolean
   ): Promise<{ success: boolean; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) {
+        return { success: false, error: 'Usuario no autenticado' };
+      }
+
+      // Actualizar estado de la invitaci√≥n
+      const { data: invitation, error: updateError } = await supabase
+        .from('chat_invitations')
+        .update({ 
+          status: accept ? 'accepted' : 'declined',
+          updated_at: new Date().toISOString()
+        })
+        .eq('id', invitationId)
+        .eq('to_profile', user.user.id)
+        .select()
+        .single();
+
+      if (updateError || !invitation) {
+        return { success: false, error: `Error al responder invitaci√≥n: ${updateError?.message}` };
+      }
+
+      // Si acepta, agregar como miembro
+      if (accept) {
+        const memberData: ChatMemberInsert = {
+          room_id: invitation.room_id!,
+          profile_id: user.user.id,
+          role: 'member',
+          is_muted: false
+        };
+
+        const { error: memberError } = await supabase
+          .from('chat_members')
+          .insert(memberData);
+
+        if (memberError) {
+          return { success: false, error: `Error al agregar miembro: ${memberError.message}` };
+        }
+      }
+
+      return { success: true };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 
+  /**
+   * Obtiene invitaciones pendientes del usuario
+   */
   async getPendingInvitations(): Promise<{
     success: boolean;
     invitations?: ChatInvitation[];
     error?: string;
   }> {
-    return {
-      success: false,
-      error: 'Sistema de chat no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+    try {
+      const { data: user } = await supabase.auth.getUser();
+      if (!user.user) {
+        return { success: false, error: 'Usuario no autenticado' };
+      }
+
+      const { data: invitations, error } = await supabase
+        .from('chat_invitations')
+        .select('*')
+        .eq('to_profile', user.user.id)
+        .eq('status', 'pending')
+        .order('created_at', { ascending: false });
+
+      if (error) {
+        return { success: false, error: `Error al obtener invitaciones: ${error.message}` };
+      }
+
+      return {
+        success: true,
+        invitations: invitations.map(mapChatInvitationRowToChatInvitation)
+      };
+
+    } catch (error) {
+      return {
+        success: false,
+        error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
+      };
+    }
   }
 }
 
+// Funciones de mapeo
+function mapChatRoomRowToChatRoom(row: ChatRoomRow): ChatRoom {
+  return {
+    id: row.id,
+    name: row.name,
+    type: row.is_public ? 'public' : 'private',
+    created_by: row.created_by,
+    created_at: row.created_at || '',
+    updated_at: row.updated_at || '',
+    description: row.description || undefined,
+    is_active: row.is_active || false
+  };
+}
+
+function mapMessageRowToChatMessage(row: MessageRow): ChatMessage {
+  return {
+    id: row.id,
+    room_id: row.room_id || '',
+    sender_id: row.sender_id,
+    content: row.content,
+    message_type: (row.message_type as 'text' | 'image' | 'file') || 'text',
+    created_at: row.created_at || '',
+    is_deleted: row.is_deleted || false
+  };
+}
+
+function mapChatInvitationRowToChatInvitation(row: ChatInvitationRow): ChatInvitation {
+  return {
+    id: row.id,
+    room_id: row.room_id || '',
+    from_profile: row.from_profile,
+    to_profile: row.to_profile,
+    status: (row.status as 'pending' | 'accepted' | 'declined') || 'pending',
+    created_at: row.created_at || '',
+    updated_at: row.updated_at || ''
+  };
+}
+
 export const chatService = new ChatService();
diff --git a/src/lib/images.ts b/src/lib/images.ts
index 33d7aed..c9fca56 100644
--- a/src/lib/images.ts
+++ b/src/lib/images.ts
@@ -1,106 +1,378 @@
-// SERVICIO TEMPORAL DE IM√ÅGENES
-// Este archivo ser√° reemplazado cuando se ejecuten las migraciones de BD
+/**
+ * SERVICIO DE IM√ÅGENES - ComplicesConecta
+ * 
+ * Sistema completo de gesti√≥n de im√°genes con soporte para:
+ * - Im√°genes p√∫blicas y privadas
+ * - Permisos granulares de acceso
+ * - Buckets de Storage organizados
+ * - Validaci√≥n y redimensionamiento
+ */
 
-export interface ImageRecord {
-  id: string;
-  profile_id: string;
-  url: string;
-  is_public: boolean;
-  type: 'profile' | 'gallery' | 'cover';
-  title?: string | null;
-  description?: string | null;
-  created_at: string;
-  updated_at: string;
+import { supabase } from '@/integrations/supabase/client';
+import type { Database } from '@/integrations/supabase/types';
+
+type ImageRow = Database['public']['Tables']['images']['Row'];
+type ImageInsert = Database['public']['Tables']['images']['Insert'];
+type ImagePermissionRow = Database['public']['Tables']['image_permissions']['Row'];
+
+export interface ImageUploadResult {
+  success: boolean;
+  imageId?: string;
+  url?: string;
+  error?: string;
 }
 
 export interface ImagePermission {
   id: string;
-  image_id: string;
-  requester_profile_id: string;
-  granted_by_profile_id: string;
-  granted: boolean;
-  created_at: string;
+  imageId: string;
+  grantedBy: string;
+  grantedTo: string;
+  createdAt: string;
 }
 
-export interface GalleryAccessRequest {
+export interface UserImage {
   id: string;
-  requester_profile_id: string;
-  target_profile_id: string;
-  status: 'pending' | 'accepted' | 'declined';
-  message?: string;
-  created_at: string;
-  decided_at?: string;
+  url: string;
+  description?: string;
+  isPublic: boolean;
+  profileId: string;
+  createdAt: string;
+  updatedAt: string;
 }
 
-class ImagesService {
-  /**
-   * VERSI√ìN TEMPORAL - Retorna error hasta que se ejecuten migraciones
-   */
-  async uploadImage(
-    file: File,
-    profileId: string,
-    isPublic: boolean = true,
-    type: 'profile' | 'gallery' | 'cover' = 'gallery',
-    title?: string,
-    description?: string
-  ): Promise<{ success: boolean; imageId?: string; url?: string; error?: string }> {
+/**
+ * Sube una imagen al bucket correspondiente
+ */
+export async function uploadImage(
+  file: File,
+  profileId: string,
+  isPublic: boolean = false,
+  description?: string
+): Promise<ImageUploadResult> {
+  try {
+    // Validar archivo
+    const validation = validateImageFile(file);
+    if (!validation.valid) {
+      return { success: false, error: validation.error };
+    }
+
+    // Determinar bucket seg√∫n tipo
+    const bucket = isPublic ? 'gallery-images' : 'profile-images';
+    const fileExt = file.name.split('.').pop();
+    const fileName = `${profileId}/${Date.now()}.${fileExt}`;
+
+    // Subir archivo a Storage
+    const { data: uploadData, error: uploadError } = await supabase.storage
+      .from(bucket)
+      .upload(fileName, file, {
+        cacheControl: '3600',
+        upsert: false
+      });
+
+    if (uploadError) {
+      return { success: false, error: `Error al subir archivo: ${uploadError.message}` };
+    }
+
+    // Obtener URL p√∫blica
+    const { data: urlData } = supabase.storage
+      .from(bucket)
+      .getPublicUrl(uploadData.path);
+
+    // Guardar metadata en BD
+    const imageData: ImageInsert = {
+      profile_id: profileId,
+      url: urlData.publicUrl,
+      description: description || null,
+      is_public: isPublic
+    };
+
+    const { data: dbData, error: dbError } = await supabase
+      .from('images')
+      .insert(imageData)
+      .select()
+      .single();
+
+    if (dbError) {
+      // Limpiar archivo subido si falla la BD
+      await supabase.storage.from(bucket).remove([uploadData.path]);
+      return { success: false, error: `Error en base de datos: ${dbError.message}` };
+    }
+
     return {
-      success: false,
-      error: 'Sistema de im√°genes no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
+      success: true,
+      imageId: dbData.id,
+      url: dbData.url
     };
-  }
 
-  async getProfileImages(
-    targetProfileId: string,
-    viewerProfileId?: string
-  ): Promise<{ success: boolean; images?: ImageRecord[]; error?: string }> {
+  } catch (error) {
     return {
       success: false,
-      error: 'Sistema de im√°genes no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
+      error: `Error inesperado: ${error instanceof Error ? error.message : 'Error desconocido'}`
     };
   }
+}
+
+/**
+ * Obtiene las im√°genes de un usuario espec√≠fico
+ */
+export async function getUserImages(profileId: string): Promise<UserImage[]> {
+  try {
+    const { data, error } = await supabase
+      .from('images')
+      .select('*')
+      .eq('profile_id', profileId)
+      .order('created_at', { ascending: false });
+
+    if (error) {
+      console.error('Error al obtener im√°genes del usuario:', error);
+      return [];
+    }
+
+    return data.map(mapImageRowToUserImage);
+  } catch (error) {
+    console.error('Error inesperado al obtener im√°genes:', error);
+    return [];
+  }
+}
+
+/**
+ * Obtiene im√°genes p√∫blicas para el feed
+ */
+export async function getPublicImages(limit: number = 20): Promise<UserImage[]> {
+  try {
+    const { data, error } = await supabase
+      .from('images')
+      .select('*')
+      .eq('is_public', true)
+      .order('created_at', { ascending: false })
+      .limit(limit);
+
+    if (error) {
+      console.error('Error al obtener im√°genes p√∫blicas:', error);
+      return [];
+    }
+
+    return data.map(mapImageRowToUserImage);
+  } catch (error) {
+    console.error('Error inesperado al obtener im√°genes p√∫blicas:', error);
+    return [];
+  }
+}
+
+/**
+ * Elimina una imagen (archivo y metadata)
+ */
+export async function deleteImage(imageId: string, profileId: string): Promise<boolean> {
+  try {
+    // Obtener datos de la imagen
+    const { data: imageData, error: fetchError } = await supabase
+      .from('images')
+      .select('*')
+      .eq('id', imageId)
+      .eq('profile_id', profileId)
+      .single();
+
+    if (fetchError || !imageData) {
+      console.error('Imagen no encontrada o sin permisos');
+      return false;
+    }
+
+    // Extraer path del archivo desde URL
+    const url = new URL(imageData.url);
+    const pathParts = url.pathname.split('/');
+    const bucket = pathParts[pathParts.length - 3]; // bucket name
+    const filePath = pathParts.slice(-2).join('/'); // profileId/filename
+
+    // Eliminar archivo de Storage
+    const { error: storageError } = await supabase.storage
+      .from(bucket)
+      .remove([filePath]);
+
+    if (storageError) {
+      console.error('Error al eliminar archivo:', storageError);
+    }
+
+    // Eliminar metadata de BD
+    const { error: dbError } = await supabase
+      .from('images')
+      .delete()
+      .eq('id', imageId)
+      .eq('profile_id', profileId);
+
+    if (dbError) {
+      console.error('Error al eliminar metadata:', dbError);
+      return false;
+    }
+
+    return true;
+  } catch (error) {
+    console.error('Error inesperado al eliminar imagen:', error);
+    return false;
+  }
+}
+
+/**
+ * Otorga permiso de acceso a una imagen privada
+ */
+export async function grantImagePermission(
+  imageId: string,
+  grantedBy: string,
+  grantedTo: string
+): Promise<boolean> {
+  try {
+    const { error } = await supabase
+      .from('image_permissions')
+      .insert({
+        image_id: imageId,
+        granted_by: grantedBy,
+        granted_to: grantedTo
+      });
 
-  async hasImagePermission(imageId: string, viewerProfileId: string): Promise<boolean> {
+    if (error) {
+      console.error('Error al otorgar permiso:', error);
+      return false;
+    }
+
+    return true;
+  } catch (error) {
+    console.error('Error inesperado al otorgar permiso:', error);
     return false;
   }
+}
 
-  async requestGalleryAccess(
-    targetProfileId: string,
-    message?: string
-  ): Promise<{ success: boolean; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de im√°genes no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+/**
+ * Revoca permiso de acceso a una imagen
+ */
+export async function revokeImagePermission(
+  imageId: string,
+  grantedBy: string,
+  grantedTo: string
+): Promise<boolean> {
+  try {
+    const { error } = await supabase
+      .from('image_permissions')
+      .delete()
+      .eq('image_id', imageId)
+      .eq('granted_by', grantedBy)
+      .eq('granted_to', grantedTo);
+
+    if (error) {
+      console.error('Error al revocar permiso:', error);
+      return false;
+    }
+
+    return true;
+  } catch (error) {
+    console.error('Error inesperado al revocar permiso:', error);
+    return false;
   }
+}
 
-  async respondToGalleryRequest(
-    requestId: string,
-    accept: boolean
-  ): Promise<{ success: boolean; error?: string }> {
-    return {
-      success: false,
-      error: 'Sistema de im√°genes no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
-    };
+/**
+ * Verifica si un usuario tiene permiso para ver una imagen
+ */
+export async function hasImagePermission(
+  imageId: string,
+  profileId: string
+): Promise<boolean> {
+  try {
+    // Verificar si la imagen es p√∫blica
+    const { data: imageData, error: imageError } = await supabase
+      .from('images')
+      .select('is_public, profile_id')
+      .eq('id', imageId)
+      .single();
+
+    if (imageError || !imageData) {
+      return false;
+    }
+
+    // Si es p√∫blica o es el propietario, tiene acceso
+    if (imageData.is_public || imageData.profile_id === profileId) {
+      return true;
+    }
+
+    // Verificar permisos expl√≠citos
+    const { data: permissionData, error: permissionError } = await supabase
+      .from('image_permissions')
+      .select('id')
+      .eq('image_id', imageId)
+      .eq('granted_to', profileId)
+      .single();
+
+    return !permissionError && !!permissionData;
+  } catch (error) {
+    console.error('Error al verificar permisos:', error);
+    return false;
   }
+}
+
+/**
+ * Obtiene todos los permisos de una imagen
+ */
+export async function getImagePermissions(imageId: string): Promise<ImagePermission[]> {
+  try {
+    const { data, error } = await supabase
+      .from('image_permissions')
+      .select('*')
+      .eq('image_id', imageId)
+      .order('created_at', { ascending: false });
 
-  async getPendingGalleryRequests(): Promise<{
-    success: boolean;
-    requests?: GalleryAccessRequest[];
-    error?: string;
-  }> {
+    if (error) {
+      console.error('Error al obtener permisos:', error);
+      return [];
+    }
+
+    return data.map(mapPermissionRowToImagePermission);
+  } catch (error) {
+    console.error('Error inesperado al obtener permisos:', error);
+    return [];
+  }
+}
+
+/**
+ * Valida un archivo de imagen
+ */
+export function validateImageFile(file: File): { valid: boolean; error?: string } {
+  const maxSize = 10 * 1024 * 1024; // 10MB
+  const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
+  
+  if (!allowedTypes.includes(file.type)) {
     return {
-      success: false,
-      error: 'Sistema de im√°genes no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
+      valid: false,
+      error: 'Tipo de archivo no permitido. Solo se permiten JPEG, PNG y WebP.'
     };
   }
-
-  async deleteImage(imageId: string): Promise<{ success: boolean; error?: string }> {
+  
+  if (file.size > maxSize) {
     return {
-      success: false,
-      error: 'Sistema de im√°genes no disponible. Ejecute primero las migraciones de base de datos (dev-scripts/migrations.sql)'
+      valid: false,
+      error: 'El archivo es demasiado grande. M√°ximo 10MB permitido.'
     };
   }
+  
+  return { valid: true };
+}
+
+// Funciones de mapeo
+function mapImageRowToUserImage(row: ImageRow): UserImage {
+  return {
+    id: row.id,
+    url: row.url,
+    description: row.description || undefined,
+    isPublic: row.is_public || false,
+    profileId: row.profile_id,
+    createdAt: row.created_at || '',
+    updatedAt: row.updated_at || ''
+  };
 }
 
-export const imagesService = new ImagesService();
+function mapPermissionRowToImagePermission(row: ImagePermissionRow): ImagePermission {
+  return {
+    id: row.id,
+    imageId: row.image_id,
+    grantedBy: row.granted_by,
+    grantedTo: row.granted_to,
+    createdAt: row.created_at || ''
+  };
+}
